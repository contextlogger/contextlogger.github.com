diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/bld.inf pyexpat-2.2.3-patched/bld.inf
--- pyexpat-2.2.3-orig/bld.inf	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/bld.inf	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,5 @@
+PRJ_PLATFORMS
+wins armi thumb
+
+PRJ_MMPFILES
+pyexpat.mmp
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/deploy.bat pyexpat-2.2.3-patched/deploy.bat
--- pyexpat-2.2.3-orig/deploy.bat	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/deploy.bat	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,24 @@
+rem A script for copying the .py files to the emulator tree.
+rem Assumes that the EPOCROOT environment variable has been set
+rem to point to the correct tree. If not, just copy manually.
+
+pushd %~dp0
+mkdir %epocroot%epoc32\release\wins\udeb\z\system\libs
+mkdir %epocroot%epoc32\release\wins\udeb\z\system\libs\xml
+mkdir %epocroot%epoc32\release\wins\udeb\z\system\libs\xml\dom
+mkdir %epocroot%epoc32\release\wins\udeb\z\system\libs\xml\parsers
+mkdir %epocroot%epoc32\release\wins\udeb\z\system\libs\xml\sax
+copy python-lib\xml\__init__.py %epocroot%epoc32\release\wins\udeb\z\system\libs\xml
+copy python-lib\xml\dom\__init__.py %epocroot%epoc32\release\wins\udeb\z\system\libs\xml\dom
+copy python-lib\xml\dom\domreg.py %epocroot%epoc32\release\wins\udeb\z\system\libs\xml\dom
+copy python-lib\xml\dom\minidom.py %epocroot%epoc32\release\wins\udeb\z\system\libs\xml\dom
+copy python-lib\xml\dom\pulldom.py %epocroot%epoc32\release\wins\udeb\z\system\libs\xml\dom
+copy python-lib\xml\parsers\__init__.py %epocroot%epoc32\release\wins\udeb\z\system\libs\xml\parsers
+copy python-lib\xml\parsers\expat.py %epocroot%epoc32\release\wins\udeb\z\system\libs\xml\parsers
+copy python-lib\xml\sax\__init__.py %epocroot%epoc32\release\wins\udeb\z\system\libs\xml\sax
+copy python-lib\xml\sax\_exceptions.py %epocroot%epoc32\release\wins\udeb\z\system\libs\xml\sax
+copy python-lib\xml\sax\expatreader.py %epocroot%epoc32\release\wins\udeb\z\system\libs\xml\sax
+copy python-lib\xml\sax\handler.py %epocroot%epoc32\release\wins\udeb\z\system\libs\xml\sax
+copy python-lib\xml\sax\saxutils.py %epocroot%epoc32\release\wins\udeb\z\system\libs\xml\sax
+copy python-lib\xml\sax\xmlreader.py %epocroot%epoc32\release\wins\udeb\z\system\libs\xml\sax
+popd
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/doc/COPYING pyexpat-2.2.3-patched/doc/COPYING
--- pyexpat-2.2.3-orig/doc/COPYING	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/doc/COPYING	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,289 @@
+LICENSING INFORMATION
+
+
+
+
+Expat 1.95.8 is covered by the following license:
+
+
+Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd
+                               and Clark Cooper
+Copyright (c) 2001, 2002, 2003 Expat maintainers.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+
+
+``pyexpat`` (from Python 2.2.3) is covered by the following license:
+
+A. HISTORY OF THE SOFTWARE
+==========================
+
+Python was created in the early 1990s by Guido van Rossum at Stichting
+Mathematisch Centrum (CWI, see http://www.cwi.nl) in the Netherlands
+as a successor of a language called ABC.  Guido remains Python's
+principal author, although it includes many contributions from others.
+
+In 1995, Guido continued his work on Python at the Corporation for
+National Research Initiatives (CNRI, see http://www.cnri.reston.va.us)
+in Reston, Virginia where he released several versions of the
+software.
+
+In May 2000, Guido and the Python core development team moved to
+BeOpen.com to form the BeOpen PythonLabs team.  In October of the same
+year, the PythonLabs team moved to Digital Creations (now Zope
+Corporation, see http://www.zope.com).  In 2001, the Python Software
+Foundation (PSF, see http://www.python.org/psf/) was formed, a
+non-profit organization created specifically to own Python-related
+Intellectual Property.  Zope Corporation is a sponsoring member of
+the PSF.
+
+All Python releases are Open Source (see http://www.opensource.org for
+the Open Source Definition).  Historically, most, but not all, Python
+releases have also been GPL-compatible; the table below summarizes
+the various releases.
+
+    Release         Derived     Year        Owner       GPL-
+		    from                                compatible? (1)
+
+    0.9.0 thru 1.2              1991-1995   CWI         yes
+    1.3 thru 1.5.2  1.2         1995-1999   CNRI        yes
+    1.6             1.5.2       2000        CNRI        no
+    2.0             1.6         2000        BeOpen.com  no
+    1.6.1           1.6         2001        CNRI        no
+    2.1             2.0+1.6.1   2001        PSF         no
+    2.0.1           2.0+1.6.1   2001        PSF         yes
+    2.1.1           2.1+2.0.1   2001        PSF         yes
+    2.2             2.1.1       2001        PSF         yes
+    2.1.2           2.1.1       2002        PSF         yes
+    2.1.3           2.1.2       2002        PSF         yes
+    2.2.1           2.2         2002        PSF         yes
+    2.2.2           2.2.1       2002        PSF         yes
+    2.2.3           2.2.2       2003        PSF         yes
+
+Footnotes:
+
+(1) GPL-compatible doesn't mean that we're distributing Python under
+    the GPL.  All Python licenses, unlike the GPL, let you distribute
+    a modified version without making your changes open source.  The
+    GPL-compatible licenses make it possible to combine Python with
+    other software that is released under the GPL; the others don't.
+
+Thanks to the many outside volunteers who have worked under Guido's
+direction to make these releases possible.
+
+
+B. TERMS AND CONDITIONS FOR ACCESSING OR OTHERWISE USING PYTHON
+===============================================================
+
+PSF LICENSE AGREEMENT FOR PYTHON 2.2.3
+--------------------------------------
+
+1. This LICENSE AGREEMENT is between the Python Software Foundation
+("PSF"), and the Individual or Organization ("Licensee") accessing and
+otherwise using Python 2.2.3 software in source or binary form and its
+associated documentation.
+
+2. Subject to the terms and conditions of this License Agreement, PSF
+hereby grants Licensee a nonexclusive, royalty-free, world-wide
+license to reproduce, analyze, test, perform and/or display publicly,
+prepare derivative works, distribute, and otherwise use Python 2.2.3
+alone or in any derivative version, provided, however, that PSF's
+License Agreement and PSF's notice of copyright, i.e., "Copyright (c)
+2001, 2002, 2003 Python Software Foundation; All Rights Reserved" are
+retained in Python 2.2.3 alone or in any derivative version prepared
+by Licensee.
+
+3. In the event Licensee prepares a derivative work that is based on
+or incorporates Python 2.2.3 or any part thereof, and wants to make
+the derivative work available to others as provided herein, then
+Licensee hereby agrees to include in any such work a brief summary of
+the changes made to Python 2.2.3.
+
+4. PSF is making Python 2.2.3 available to Licensee on an "AS IS"
+basis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
+IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND
+DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS
+FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 2.2.3 WILL NOT
+INFRINGE ANY THIRD PARTY RIGHTS.
+
+5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
+2.2.3 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS
+A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 2.2.3,
+OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
+
+6. This License Agreement will automatically terminate upon a material
+breach of its terms and conditions.
+
+7. Nothing in this License Agreement shall be deemed to create any
+relationship of agency, partnership, or joint venture between PSF and
+Licensee.  This License Agreement does not grant permission to use PSF
+trademarks or trade name in a trademark sense to endorse or promote
+products or services of Licensee, or any third party.
+
+8. By copying, installing or otherwise using Python 2.2.3, Licensee
+agrees to be bound by the terms and conditions of this License
+Agreement.
+
+
+BEOPEN.COM LICENSE AGREEMENT FOR PYTHON 2.0
+-------------------------------------------
+
+BEOPEN PYTHON OPEN SOURCE LICENSE AGREEMENT VERSION 1
+
+1. This LICENSE AGREEMENT is between BeOpen.com ("BeOpen"), having an
+office at 160 Saratoga Avenue, Santa Clara, CA 95051, and the
+Individual or Organization ("Licensee") accessing and otherwise using
+this software in source or binary form and its associated
+documentation ("the Software").
+
+2. Subject to the terms and conditions of this BeOpen Python License
+Agreement, BeOpen hereby grants Licensee a non-exclusive,
+royalty-free, world-wide license to reproduce, analyze, test, perform
+and/or display publicly, prepare derivative works, distribute, and
+otherwise use the Software alone or in any derivative version,
+provided, however, that the BeOpen Python License is retained in the
+Software, alone or in any derivative version prepared by Licensee.
+
+3. BeOpen is making the Software available to Licensee on an "AS IS"
+basis.  BEOPEN MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
+IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, BEOPEN MAKES NO AND
+DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS
+FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE WILL NOT
+INFRINGE ANY THIRD PARTY RIGHTS.
+
+4. BEOPEN SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF THE
+SOFTWARE FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS
+AS A RESULT OF USING, MODIFYING OR DISTRIBUTING THE SOFTWARE, OR ANY
+DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
+
+5. This License Agreement will automatically terminate upon a material
+breach of its terms and conditions.
+
+6. This License Agreement shall be governed by and interpreted in all
+respects by the law of the State of California, excluding conflict of
+law provisions.  Nothing in this License Agreement shall be deemed to
+create any relationship of agency, partnership, or joint venture
+between BeOpen and Licensee.  This License Agreement does not grant
+permission to use BeOpen trademarks or trade names in a trademark
+sense to endorse or promote products or services of Licensee, or any
+third party.  As an exception, the "BeOpen Python" logos available at
+http://www.pythonlabs.com/logos.html may be used according to the
+permissions granted on that web page.
+
+7. By copying, installing or otherwise using the software, Licensee
+agrees to be bound by the terms and conditions of this License
+Agreement.
+
+
+CNRI LICENSE AGREEMENT FOR PYTHON 1.6.1
+---------------------------------------
+
+1. This LICENSE AGREEMENT is between the Corporation for National
+Research Initiatives, having an office at 1895 Preston White Drive,
+Reston, VA 20191 ("CNRI"), and the Individual or Organization
+("Licensee") accessing and otherwise using Python 1.6.1 software in
+source or binary form and its associated documentation.
+
+2. Subject to the terms and conditions of this License Agreement, CNRI
+hereby grants Licensee a nonexclusive, royalty-free, world-wide
+license to reproduce, analyze, test, perform and/or display publicly,
+prepare derivative works, distribute, and otherwise use Python 1.6.1
+alone or in any derivative version, provided, however, that CNRI's
+License Agreement and CNRI's notice of copyright, i.e., "Copyright (c)
+1995-2001 Corporation for National Research Initiatives; All Rights
+Reserved" are retained in Python 1.6.1 alone or in any derivative
+version prepared by Licensee.  Alternately, in lieu of CNRI's License
+Agreement, Licensee may substitute the following text (omitting the
+quotes): "Python 1.6.1 is made available subject to the terms and
+conditions in CNRI's License Agreement.  This Agreement together with
+Python 1.6.1 may be located on the Internet using the following
+unique, persistent identifier (known as a handle): 1895.22/1013.  This
+Agreement may also be obtained from a proxy server on the Internet
+using the following URL: http://hdl.handle.net/1895.22/1013".
+
+3. In the event Licensee prepares a derivative work that is based on
+or incorporates Python 1.6.1 or any part thereof, and wants to make
+the derivative work available to others as provided herein, then
+Licensee hereby agrees to include in any such work a brief summary of
+the changes made to Python 1.6.1.
+
+4. CNRI is making Python 1.6.1 available to Licensee on an "AS IS"
+basis.  CNRI MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
+IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, CNRI MAKES NO AND
+DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS
+FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 1.6.1 WILL NOT
+INFRINGE ANY THIRD PARTY RIGHTS.
+
+5. CNRI SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
+1.6.1 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS
+A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 1.6.1,
+OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
+
+6. This License Agreement will automatically terminate upon a material
+breach of its terms and conditions.
+
+7. This License Agreement shall be governed by the federal
+intellectual property law of the United States, including without
+limitation the federal copyright law, and, to the extent such
+U.S. federal law does not apply, by the law of the Commonwealth of
+Virginia, excluding Virginia's conflict of law provisions.
+Notwithstanding the foregoing, with regard to derivative works based
+on Python 1.6.1 that incorporate non-separable material that was
+previously distributed under the GNU General Public License (GPL), the
+law of the Commonwealth of Virginia shall govern this License
+Agreement only as to issues arising under or with respect to
+Paragraphs 4, 5, and 7 of this License Agreement.  Nothing in this
+License Agreement shall be deemed to create any relationship of
+agency, partnership, or joint venture between CNRI and Licensee.  This
+License Agreement does not grant permission to use CNRI trademarks or
+trade name in a trademark sense to endorse or promote products or
+services of Licensee, or any third party.
+
+8. By clicking on the "ACCEPT" button where indicated, or by copying,
+installing or otherwise using Python 1.6.1, Licensee agrees to be
+bound by the terms and conditions of this License Agreement.
+
+        ACCEPT
+
+
+CWI LICENSE AGREEMENT FOR PYTHON 0.9.0 THROUGH 1.2
+--------------------------------------------------
+
+Copyright (c) 1991 - 1995, Stichting Mathematisch Centrum Amsterdam,
+The Netherlands.  All rights reserved.
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Stichting Mathematisch
+Centrum or CWI not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE
+FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/inc/expat_config.h pyexpat-2.2.3-patched/inc/expat_config.h
--- pyexpat-2.2.3-orig/inc/expat_config.h	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/inc/expat_config.h	2007-12-21 11:38:25.000000000 +0200
@@ -0,0 +1,111 @@
+/* We are not using a "configure" script for Symbian builds,
+   so instead we define the configuration here. 
+
+   These settings seem okay for Symbian 7.0s, at least. They were
+   taken more or less directly from SyExpat, see
+   http://www.toddsoftware.com/ for more information.
+
+   Note that the XML_UNICODE option is presently commented out--
+   should look more carefully into Expat Unicode support, and
+   how PyExpat maps Expat Unicode strings to Python Unicode strings. XXX
+*/
+
+#ifndef __EXPAT_CONFIG_H__
+#define __EXPAT_CONFIG_H__
+
+/* 	Copyright 2000, Clark Cooper
+   	All rights reserved.
+
+   	This is free software. You are permitted to copy, distribute, or modify
+   	it under the terms of the MIT/X license (contained in the COPYING file
+   	with this distribution.)
+*/
+
+#if !defined(__E32DEF_H__) && defined(NULL)
+#undef NULL
+#endif
+
+// else e32def.h gives errors w/v3.0 SDK, due to GCCE differences, maybe
+#define __REMOVE_PLATSEC_DIAGNOSTIC_STRINGS__
+
+#include <e32def.h>
+
+// Symbian is little endian
+#define BYTEORDER 1234
+
+#undef HAVE_CHECK_H
+
+/* We do not have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+#define HAVE_FCNTL_H 1
+
+// getpagesize function is in unistd.h
+#define HAVE_GETPAGESIZE 1
+
+/* The the <inttypes.h> header file is not present. */
+#undef HAVE_INTTYPES_H
+
+/* Symbian has memmove and also bcopy if not using strict ansi*/
+#define HAVE_MEMMOVE 1
+
+#undef HAVE_MEMORY_H
+
+/* Symbian does not support the `mmap' system call. */
+#undef HAVE_MMAP
+
+/* Symbian  does not have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* But it does have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* We do not have <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* But we do have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* We have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* We  have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* We have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* we  have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Symbian is little endian */
+#undef WORDS_BIGENDIAN
+
+/* We do not use XML context buffers to save memory*/
+#undef XML_CONTEXT_BYTES	
+
+// We want unicode output for string etc--
+// no we don't, as this option seems to break things--
+// at least basic_test.py produces garbageish output,
+// and PDIS no longer works with this option
+//#define XML_UNICODE 1
+
+/* We do not currently want DTD support. */
+#undef XML_DTD
+
+/* We want Namspace Support */
+#define XML_NS 1
+
+/* Make sure const is defined at the compiler level and not defined */
+#undef const
+
+/* defined in sys\types.h */
+#undef off_t
+
+/* defined in sys\types.h */
+#undef size_t
+
+#ifndef NULL
+#define NULL 0L
+#endif
+
+#endif // __EXPAT_CONFIG_H__
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/pyexpat-series60_v12.pkg pyexpat-2.2.3-patched/pyexpat-series60_v12.pkg
--- pyexpat-2.2.3-orig/pyexpat-series60_v12.pkg	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/pyexpat-series60_v12.pkg	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,57 @@
+
+; We could otherwise simply use a 0 value
+; (as Python imports should be purely name-based),
+; but SIS file prerequisites do require a UID,
+; so we are using a UID allocated from Symbian.
+#{"pyexpat"}, (0x10206ba2), 1, 8, 0
+
+;;;
+;;; Series 60 v0.9
+;;;
+(0x101f6f88), 0, 0, 0, {"Series60ProductID"}
+
+;;;
+;;; Python for Series 60
+;;;
+(0x10201510), 0, 0, 0, {"Python for Series 60"}
+
+;;;
+;;; license
+;;;
+; "doc\COPYING" - "", FILETEXT, TEXTCONTINUE
+
+;;;
+;;; native extension (includes Expat)
+;;;
+"epoc32\release\armi\urel\pyexpat.pyd" -
+"!:\system\libs\pyexpat.pyd"
+
+;;;
+;;; standard Python XML library
+;;;
+"python-lib\xml\dom\domreg.py" -
+"!:\system\libs\xml\dom\domreg.py"
+"python-lib\xml\dom\minidom.py" -
+"!:\system\libs\xml\dom\minidom.py"
+"python-lib\xml\dom\pulldom.py" -
+"!:\system\libs\xml\dom\pulldom.py"
+"python-lib\xml\dom\__init__.py" -
+"!:\system\libs\xml\dom\__init__.py"
+"python-lib\xml\parsers\expat.py" -
+"!:\system\libs\xml\parsers\expat.py"
+"python-lib\xml\parsers\__init__.py" -
+"!:\system\libs\xml\parsers\__init__.py"
+"python-lib\xml\sax\expatreader.py" -
+"!:\system\libs\xml\sax\expatreader.py"
+"python-lib\xml\sax\handler.py" -
+"!:\system\libs\xml\sax\handler.py"
+"python-lib\xml\sax\saxutils.py" -
+"!:\system\libs\xml\sax\saxutils.py"
+"python-lib\xml\sax\xmlreader.py" -
+"!:\system\libs\xml\sax\xmlreader.py"
+"python-lib\xml\sax\_exceptions.py" -
+"!:\system\libs\xml\sax\_exceptions.py"
+"python-lib\xml\sax\__init__.py" -
+"!:\system\libs\xml\sax\__init__.py"
+"python-lib\xml\__init__.py" -
+"!:\system\libs\xml\__init__.py"
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/pyexpat-series60_v20.pkg pyexpat-2.2.3-patched/pyexpat-series60_v20.pkg
--- pyexpat-2.2.3-orig/pyexpat-series60_v20.pkg	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/pyexpat-series60_v20.pkg	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,57 @@
+
+; We could otherwise simply use a 0 value
+; (as Python imports should be purely name-based),
+; but SIS file prerequisites do require a UID,
+; so we are using a UID allocated from Symbian.
+#{"pyexpat"}, (0x10206ba2), 1, 8, 0
+
+;;;
+;;; Series 60
+;;;
+(0x101f7960), 0, 0, 0, {"Series60ProductID"}
+
+;;;
+;;; Python for Series 60
+;;;
+(0x10201510), 0, 0, 0, {"Python for Series 60"}
+
+;;;
+;;; license
+;;;
+; "doc\COPYING" - "", FILETEXT, TEXTCONTINUE
+
+;;;
+;;; native extension (includes Expat)
+;;;
+"epoc32\release\armi\urel\pyexpat.pyd" -
+"!:\system\libs\pyexpat.pyd"
+
+;;;
+;;; standard Python XML library
+;;;
+"python-lib\xml\dom\domreg.py" -
+"!:\system\libs\xml\dom\domreg.py"
+"python-lib\xml\dom\minidom.py" -
+"!:\system\libs\xml\dom\minidom.py"
+"python-lib\xml\dom\pulldom.py" -
+"!:\system\libs\xml\dom\pulldom.py"
+"python-lib\xml\dom\__init__.py" -
+"!:\system\libs\xml\dom\__init__.py"
+"python-lib\xml\parsers\expat.py" -
+"!:\system\libs\xml\parsers\expat.py"
+"python-lib\xml\parsers\__init__.py" -
+"!:\system\libs\xml\parsers\__init__.py"
+"python-lib\xml\sax\expatreader.py" -
+"!:\system\libs\xml\sax\expatreader.py"
+"python-lib\xml\sax\handler.py" -
+"!:\system\libs\xml\sax\handler.py"
+"python-lib\xml\sax\saxutils.py" -
+"!:\system\libs\xml\sax\saxutils.py"
+"python-lib\xml\sax\xmlreader.py" -
+"!:\system\libs\xml\sax\xmlreader.py"
+"python-lib\xml\sax\_exceptions.py" -
+"!:\system\libs\xml\sax\_exceptions.py"
+"python-lib\xml\sax\__init__.py" -
+"!:\system\libs\xml\sax\__init__.py"
+"python-lib\xml\__init__.py" -
+"!:\system\libs\xml\__init__.py"
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/pyexpat.mmp pyexpat-2.2.3-patched/pyexpat.mmp
--- pyexpat-2.2.3-orig/pyexpat.mmp	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/pyexpat.mmp	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,50 @@
+TARGET		pyexpat.pyd
+targettype 	dll
+targetpath      \system\libs\
+
+UID             0x1000008d 0x10206ba2
+//EPOCCALLDLLENTRYPOINTS
+
+// I guess we must do an abld freeze or something for this
+//EXPORTUNFROZEN
+NOSTRICTDEF
+#if defined(WINS)
+DEFFILE		.\pyexpat-wins.frz
+#else if define(ARM)
+DEFFILE		.\pyexpat-arm.frz
+#endif
+
+systeminclude 	\epoc32\include
+systeminclude 	\epoc32\include\libc
+userinclude 	\epoc32\..\python-port-s60\symbian_python\symbian
+userinclude 	\epoc32\..\python-port-s60\symbian_python\include
+userinclude 	\epoc32\..\python-port-s60\symbian_python\python
+systeminclude   inc
+
+userinclude	inc
+userinclude 	..\expat-1.95.8-patched\lib
+
+sourcepath 	src
+source		dllentry.cpp
+source		logging.cpp
+source 		pyexpat.cpp
+
+sourcepath 	..\expat-1.95.8-patched\lib
+source      	xmlparse.c  
+source      	xmlrole.c
+source      	xmltok.c
+
+// these are actually used as includes, to grab some inline
+// code, so we do not want object files for them;
+// renamed to *.inl
+//source      	xmltok_impl.c
+//source      	xmltok_ns.c 
+
+LIBRARY 	estlib.lib 
+library 	euser.lib 
+//library 	efsrv.lib
+LIBRARY 	python222.lib
+library		flogger.lib
+
+macro		HAVE_EXPAT_H
+macro		HAVE_EXPAT_CONFIG_H
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/python-lib/xml/__init__.py pyexpat-2.2.3-patched/python-lib/xml/__init__.py
--- pyexpat-2.2.3-orig/python-lib/xml/__init__.py	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/python-lib/xml/__init__.py	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,42 @@
+"""Core XML support for Python.
+
+This package contains three sub-packages:
+
+dom -- The W3C Document Object Model.  This supports DOM Level 1 +
+       Namespaces.
+
+parsers -- Python wrappers for XML parsers (currently only supports Expat).
+
+sax -- The Simple API for XML, developed by XML-Dev, led by David
+       Megginson and ported to Python by Lars Marius Garshol.  This
+       supports the SAX 2 API.
+"""
+
+
+__all__ = ["dom", "parsers", "sax"]
+
+# When being checked-out without options, this has the form
+# "<dollar>Revision: x.y </dollar>"
+# When exported using -kv, it is "x.y".
+__version__ = "$Revision: 1.11 $".split()[-2:][0]
+
+
+_MINIMUM_XMLPLUS_VERSION = (0, 6, 1)
+
+
+try:
+    import _xmlplus
+except ImportError:
+    pass
+else:
+    try:
+        v = _xmlplus.version_info
+    except AttributeError:
+        # _xmlplue is too old; ignore it
+        pass
+    else:
+        if v >= _MINIMUM_XMLPLUS_VERSION:
+            import sys
+            sys.modules[__name__] = _xmlplus
+        else:
+            del v
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/python-lib/xml/dom/__init__.py pyexpat-2.2.3-patched/python-lib/xml/dom/__init__.py
--- pyexpat-2.2.3-orig/python-lib/xml/dom/__init__.py	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/python-lib/xml/dom/__init__.py	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,125 @@
+"""W3C Document Object Model implementation for Python.
+
+The Python mapping of the Document Object Model is documented in the
+Python Library Reference in the section on the xml.dom package.
+
+This package contains the following modules:
+
+minidom -- A simple implementation of the Level 1 DOM with namespace
+           support added (based on the Level 2 specification) and other
+           minor Level 2 functionality.
+
+pulldom -- DOM builder supporting on-demand tree-building for selected
+           subtrees of the document.
+
+"""
+
+
+class Node:
+    """Class giving the NodeType constants."""
+
+    # DOM implementations may use this as a base class for their own
+    # Node implementations.  If they don't, the constants defined here
+    # should still be used as the canonical definitions as they match
+    # the values given in the W3C recommendation.  Client code can
+    # safely refer to these values in all tests of Node.nodeType
+    # values.
+
+    ELEMENT_NODE                = 1
+    ATTRIBUTE_NODE              = 2
+    TEXT_NODE                   = 3
+    CDATA_SECTION_NODE          = 4
+    ENTITY_REFERENCE_NODE       = 5
+    ENTITY_NODE                 = 6
+    PROCESSING_INSTRUCTION_NODE = 7
+    COMMENT_NODE                = 8
+    DOCUMENT_NODE               = 9
+    DOCUMENT_TYPE_NODE          = 10
+    DOCUMENT_FRAGMENT_NODE      = 11
+    NOTATION_NODE               = 12
+
+
+#ExceptionCode
+INDEX_SIZE_ERR                 = 1
+DOMSTRING_SIZE_ERR             = 2
+HIERARCHY_REQUEST_ERR          = 3
+WRONG_DOCUMENT_ERR             = 4
+INVALID_CHARACTER_ERR          = 5
+NO_DATA_ALLOWED_ERR            = 6
+NO_MODIFICATION_ALLOWED_ERR    = 7
+NOT_FOUND_ERR                  = 8
+NOT_SUPPORTED_ERR              = 9
+INUSE_ATTRIBUTE_ERR            = 10
+INVALID_STATE_ERR              = 11
+SYNTAX_ERR                     = 12
+INVALID_MODIFICATION_ERR       = 13
+NAMESPACE_ERR                  = 14
+INVALID_ACCESS_ERR             = 15
+
+
+class DOMException(Exception):
+    """Abstract base class for DOM exceptions.
+    Exceptions with specific codes are specializations of this class."""
+
+    def __init__(self, *args, **kw):
+        if self.__class__ is DOMException:
+            raise RuntimeError(
+                "DOMException should not be instantiated directly")
+        apply(Exception.__init__, (self,) + args, kw)
+
+    def _get_code(self):
+        return self.code
+
+
+class IndexSizeErr(DOMException):
+    code = INDEX_SIZE_ERR
+
+class DomstringSizeErr(DOMException):
+    code = DOMSTRING_SIZE_ERR
+
+class HierarchyRequestErr(DOMException):
+    code = HIERARCHY_REQUEST_ERR
+
+class WrongDocumentErr(DOMException):
+    code = WRONG_DOCUMENT_ERR
+
+class InvalidCharacterErr(DOMException):
+    code = INVALID_CHARACTER_ERR
+
+class NoDataAllowedErr(DOMException):
+    code = NO_DATA_ALLOWED_ERR
+
+class NoModificationAllowedErr(DOMException):
+    code = NO_MODIFICATION_ALLOWED_ERR
+
+class NotFoundErr(DOMException):
+    code = NOT_FOUND_ERR
+
+class NotSupportedErr(DOMException):
+    code = NOT_SUPPORTED_ERR
+
+class InuseAttributeErr(DOMException):
+    code = INUSE_ATTRIBUTE_ERR
+
+class InvalidStateErr(DOMException):
+    code = INVALID_STATE_ERR
+
+class SyntaxErr(DOMException):
+    code = SYNTAX_ERR
+
+class InvalidModificationErr(DOMException):
+    code = INVALID_MODIFICATION_ERR
+
+class NamespaceErr(DOMException):
+    code = NAMESPACE_ERR
+
+class InvalidAccessErr(DOMException):
+    code = INVALID_ACCESS_ERR
+
+
+XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace"
+XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/"
+XHTML_NAMESPACE = "http://www.w3.org/1999/xhtml"
+EMPTY_NAMESPACE = None
+
+from domreg import getDOMImplementation,registerDOMImplementation
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/python-lib/xml/dom/domreg.py pyexpat-2.2.3-patched/python-lib/xml/dom/domreg.py
--- pyexpat-2.2.3-orig/python-lib/xml/dom/domreg.py	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/python-lib/xml/dom/domreg.py	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,76 @@
+"""Registration facilities for DOM. This module should not be used
+directly. Instead, the functions getDOMImplementation and
+registerDOMImplementation should be imported from xml.dom."""
+
+# This is a list of well-known implementations.  Well-known names
+# should be published by posting to xml-sig@python.org, and are
+# subsequently recorded in this file.
+
+well_known_implementations = {
+    'minidom':'xml.dom.minidom',
+    '4DOM': 'xml.dom.DOMImplementation',
+    }
+
+# DOM implementations not officially registered should register
+# themselves with their
+
+registered = {}
+
+def registerDOMImplementation(name, factory):
+    """registerDOMImplementation(name, factory)
+
+    Register the factory function with the name. The factory function
+    should return an object which implements the DOMImplementation
+    interface. The factory function can either return the same object,
+    or a new one (e.g. if that implementation supports some
+    customization)."""
+    
+    registered[name] = factory
+
+def _good_enough(dom, features):
+    "_good_enough(dom, features) -> Return 1 if the dom offers the features"
+    for f,v in features:
+        if not dom.hasFeature(f,v):
+            return 0
+    return 1
+
+def getDOMImplementation(name = None, features = ()):
+    """getDOMImplementation(name = None, features = ()) -> DOM implementation.
+
+    Return a suitable DOM implementation. The name is either
+    well-known, the module name of a DOM implementation, or None. If
+    it is not None, imports the corresponding module and returns
+    DOMImplementation object if the import succeeds.
+
+    If name is not given, consider the available implementations to
+    find one with the required feature set. If no implementation can
+    be found, raise an ImportError. The features list must be a sequence
+    of (feature, version) pairs which are passed to hasFeature."""
+    
+    import os
+    creator = None
+    mod = well_known_implementations.get(name)
+    if mod:
+        mod = __import__(mod, {}, {}, ['getDOMImplementation'])
+        return mod.getDOMImplementation()
+    elif name:
+        return registered[name]()
+    elif os.environ.has_key("PYTHON_DOM"):
+        return getDOMImplementation(name = os.environ["PYTHON_DOM"])
+
+    # User did not specify a name, try implementations in arbitrary
+    # order, returning the one that has the required features
+    for creator in registered.values():
+        dom = creator()
+        if _good_enough(dom, features):
+            return dom
+
+    for creator in well_known_implementations.keys():
+        try:
+            dom = getDOMImplementation(name = creator)
+        except StandardError: # typically ImportError, or AttributeError
+            continue
+        if _good_enough(dom, features):
+            return dom
+
+    raise ImportError,"no suitable DOM implementation found"
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/python-lib/xml/dom/minidom.py pyexpat-2.2.3-patched/python-lib/xml/dom/minidom.py
--- pyexpat-2.2.3-orig/python-lib/xml/dom/minidom.py	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/python-lib/xml/dom/minidom.py	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,970 @@
+"""\
+minidom.py -- a lightweight DOM implementation.
+
+parse("foo.xml")
+
+parseString("<foo><bar/></foo>")
+
+Todo:
+=====
+ * convenience methods for getting elements and text.
+ * more testing
+ * bring some of the writer and linearizer code into conformance with this
+        interface
+ * SAX 2 namespaces
+"""
+
+import string
+_string = string
+del string
+
+from xml.dom import HierarchyRequestErr, EMPTY_NAMESPACE
+
+# localize the types, and allow support for Unicode values if available:
+import types
+_TupleType = types.TupleType
+try:
+    _StringTypes = (types.StringType, types.UnicodeType)
+except AttributeError:
+    _StringTypes = (types.StringType,)
+del types
+
+import xml.dom
+
+
+if list is type([]):
+    class NodeList(list):
+        def item(self, index):
+            if 0 <= index < len(self):
+                return self[index]
+
+        length = property(lambda self: len(self),
+                          doc="The number of nodes in the NodeList.")
+
+else:
+    def NodeList():
+        return []
+    
+
+class Node(xml.dom.Node):
+    allnodes = {}
+    _debug = 0
+    _makeParentNodes = 1
+    debug = None
+    childNodeTypes = ()
+    namespaceURI = None # this is non-null only for elements and attributes
+    parentNode = None
+    ownerDocument = None
+
+    def __init__(self):
+        self.childNodes = NodeList()
+        if Node._debug:
+            index = repr(id(self)) + repr(self.__class__)
+            Node.allnodes[index] = repr(self.__dict__)
+            if Node.debug is None:
+                Node.debug = _get_StringIO()
+                #open("debug4.out", "w")
+            Node.debug.write("create %s\n" % index)
+
+    def __nonzero__(self):
+        return 1
+
+    def toxml(self):
+        writer = _get_StringIO()
+        self.writexml(writer)
+        return writer.getvalue()
+
+    def toprettyxml(self, indent="\t", newl="\n"):
+        # indent = the indentation string to prepend, per level
+        # newl = the newline string to append
+        writer = _get_StringIO()
+        self.writexml(writer, "", indent, newl)
+        return writer.getvalue()
+
+    def hasChildNodes(self):
+        if self.childNodes:
+            return 1
+        else:
+            return 0
+
+    def _get_firstChild(self):
+        if self.childNodes:
+            return self.childNodes[0]
+
+    def _get_lastChild(self):
+        if self.childNodes:
+            return self.childNodes[-1]
+
+    try:
+        property
+    except NameError:
+        def __getattr__(self, key):
+            if key[0:2] == "__":
+                raise AttributeError, key
+            # getattr should never call getattr!
+            if self.__dict__.has_key("inGetAttr"):
+                del self.inGetAttr
+                raise AttributeError, key
+
+            prefix, attrname = key[:5], key[5:]
+            if prefix == "_get_":
+                self.inGetAttr = 1
+                if hasattr(self, attrname):
+                    del self.inGetAttr
+                    return (lambda self=self, attrname=attrname:
+                                    getattr(self, attrname))
+                else:
+                    del self.inGetAttr
+                    raise AttributeError, key
+            else:
+                self.inGetAttr = 1
+                try:
+                    func = getattr(self, "_get_" + key)
+                except AttributeError:
+                    raise AttributeError, key
+                del self.inGetAttr
+                return func()
+    else:
+        firstChild = property(_get_firstChild,
+                              doc="First child node, or None.")
+        lastChild = property(_get_lastChild,
+                             doc="Last child node, or None.")
+
+    def insertBefore(self, newChild, refChild):
+        if newChild.nodeType == self.DOCUMENT_FRAGMENT_NODE:
+            for c in tuple(newChild.childNodes):
+                self.insertBefore(c, refChild)
+            ### The DOM does not clearly specify what to return in this case
+            return newChild
+        if newChild.nodeType not in self.childNodeTypes:
+            raise HierarchyRequestErr, \
+                  "%s cannot be child of %s" % (repr(newChild), repr(self))
+        if newChild.parentNode is not None:
+            newChild.parentNode.removeChild(newChild)
+        if refChild is None:
+            self.appendChild(newChild)
+        else:
+            index = self.childNodes.index(refChild)
+            self.childNodes.insert(index, newChild)
+            newChild.nextSibling = refChild
+            refChild.previousSibling = newChild
+            if index:
+                node = self.childNodes[index-1]
+                node.nextSibling = newChild
+                newChild.previousSibling = node
+            else:
+                newChild.previousSibling = None
+            if self._makeParentNodes:
+                newChild.parentNode = self
+        return newChild
+
+    def appendChild(self, node):
+        if node.nodeType == self.DOCUMENT_FRAGMENT_NODE:
+            for c in tuple(node.childNodes):
+                self.appendChild(c)
+            ### The DOM does not clearly specify what to return in this case
+            return node
+        if node.nodeType not in self.childNodeTypes:
+            raise HierarchyRequestErr, \
+                  "%s cannot be child of %s" % (repr(node), repr(self))
+        if node.parentNode is not None:
+            node.parentNode.removeChild(node)
+        if self.childNodes:
+            last = self.lastChild
+            node.previousSibling = last
+            last.nextSibling = node
+        else:
+            node.previousSibling = None
+        node.nextSibling = None
+        self.childNodes.append(node)
+        if self._makeParentNodes:
+            node.parentNode = self
+        return node
+
+    def replaceChild(self, newChild, oldChild):
+        if newChild.nodeType == self.DOCUMENT_FRAGMENT_NODE:
+            refChild = oldChild.nextSibling
+            self.removeChild(oldChild)
+            return self.insertBefore(newChild, refChild)
+        if newChild.nodeType not in self.childNodeTypes:
+            raise HierarchyRequestErr, \
+                  "%s cannot be child of %s" % (repr(newChild), repr(self))
+        if newChild.parentNode is not None:
+            newChild.parentNode.removeChild(newChild)
+        if newChild is oldChild:
+            return
+        index = self.childNodes.index(oldChild)
+        self.childNodes[index] = newChild
+        if self._makeParentNodes:
+            newChild.parentNode = self
+            oldChild.parentNode = None
+        newChild.nextSibling = oldChild.nextSibling
+        newChild.previousSibling = oldChild.previousSibling
+        oldChild.nextSibling = None
+        oldChild.previousSibling = None
+        if newChild.previousSibling:
+            newChild.previousSibling.nextSibling = newChild
+        if newChild.nextSibling:
+            newChild.nextSibling.previousSibling = newChild
+        return oldChild
+
+    def removeChild(self, oldChild):
+        self.childNodes.remove(oldChild)
+        if oldChild.nextSibling is not None:
+            oldChild.nextSibling.previousSibling = oldChild.previousSibling
+        if oldChild.previousSibling is not None:
+            oldChild.previousSibling.nextSibling = oldChild.nextSibling
+        oldChild.nextSibling = oldChild.previousSibling = None
+
+        if self._makeParentNodes:
+            oldChild.parentNode = None
+        return oldChild
+
+    def normalize(self):
+        L = []
+        for child in self.childNodes:
+            if child.nodeType == Node.TEXT_NODE:
+                data = child.data
+                if data and L and L[-1].nodeType == child.nodeType:
+                    # collapse text node
+                    node = L[-1]
+                    node.data = node.nodeValue = node.data + child.data
+                    node.nextSibling = child.nextSibling
+                    child.unlink()
+                elif data:
+                    if L:
+                        L[-1].nextSibling = child
+                        child.previousSibling = L[-1]
+                    else:
+                        child.previousSibling = None
+                    L.append(child)
+                else:
+                    # empty text node; discard
+                    child.unlink()
+            else:
+                if L:
+                    L[-1].nextSibling = child
+                    child.previousSibling = L[-1]
+                else:
+                    child.previousSibling = None
+                L.append(child)
+                if child.nodeType == Node.ELEMENT_NODE:
+                    child.normalize()
+        self.childNodes[:] = L
+
+    def cloneNode(self, deep):
+        import new
+        clone = new.instance(self.__class__, self.__dict__.copy())
+        if self._makeParentNodes:
+            clone.parentNode = None
+        clone.childNodes = NodeList()
+        if deep:
+            for child in self.childNodes:
+                clone.appendChild(child.cloneNode(1))
+        return clone
+
+    # DOM Level 3 (Working Draft 2001-Jan-26)
+
+    def isSameNode(self, other):
+        return self is other
+
+    # minidom-specific API:
+
+    def unlink(self):
+        self.parentNode = self.ownerDocument = None
+        for child in self.childNodes:
+            child.unlink()
+        self.childNodes = None
+        self.previousSibling = None
+        self.nextSibling = None
+        if Node._debug:
+            index = repr(id(self)) + repr(self.__class__)
+            self.debug.write("Deleting: %s\n" % index)
+            del Node.allnodes[index]
+
+def _write_data(writer, data):
+    "Writes datachars to writer."
+    replace = _string.replace
+    data = replace(data, "&", "&amp;")
+    data = replace(data, "<", "&lt;")
+    data = replace(data, "\"", "&quot;")
+    data = replace(data, ">", "&gt;")
+    writer.write(data)
+
+def _getElementsByTagNameHelper(parent, name, rc):
+    for node in parent.childNodes:
+        if node.nodeType == Node.ELEMENT_NODE and \
+            (name == "*" or node.tagName == name):
+            rc.append(node)
+        _getElementsByTagNameHelper(node, name, rc)
+    return rc
+
+def _getElementsByTagNameNSHelper(parent, nsURI, localName, rc):
+    for node in parent.childNodes:
+        if node.nodeType == Node.ELEMENT_NODE:
+            if ((localName == "*" or node.localName == localName) and
+                (nsURI == "*" or node.namespaceURI == nsURI)):
+                rc.append(node)
+            _getElementsByTagNameNSHelper(node, nsURI, localName, rc)
+    return rc
+
+class DocumentFragment(Node):
+    nodeType = Node.DOCUMENT_FRAGMENT_NODE
+    nodeName = "#document-fragment"
+    nodeValue = None
+    attributes = None
+    parentNode = None
+    childNodeTypes = (Node.ELEMENT_NODE,
+                      Node.TEXT_NODE,
+                      Node.CDATA_SECTION_NODE,
+                      Node.ENTITY_REFERENCE_NODE,
+                      Node.PROCESSING_INSTRUCTION_NODE,
+                      Node.COMMENT_NODE,
+                      Node.NOTATION_NODE)
+
+
+class Attr(Node):
+    nodeType = Node.ATTRIBUTE_NODE
+    attributes = None
+    ownerElement = None
+    childNodeTypes = (Node.TEXT_NODE, Node.ENTITY_REFERENCE_NODE)
+
+    def __init__(self, qName, namespaceURI=EMPTY_NAMESPACE, localName=None, prefix=None):
+        # skip setattr for performance
+        d = self.__dict__
+        d["localName"] = localName or qName
+        d["nodeName"] = d["name"] = qName
+        d["namespaceURI"] = namespaceURI
+        d["prefix"] = prefix
+        Node.__init__(self)
+        # nodeValue and value are set elsewhere
+
+    def __setattr__(self, name, value):
+        d = self.__dict__
+        if name in ("value", "nodeValue"):
+            d["value"] = d["nodeValue"] = value
+        elif name in ("name", "nodeName"):
+            d["name"] = d["nodeName"] = value
+        else:
+            d[name] = value
+
+    def cloneNode(self, deep):
+        clone = Node.cloneNode(self, deep)
+        if clone.__dict__.has_key("ownerElement"):
+            del clone.ownerElement
+        return clone
+
+
+class NamedNodeMap:
+    """The attribute list is a transient interface to the underlying
+    dictionaries.  Mutations here will change the underlying element's
+    dictionary.
+
+    Ordering is imposed artificially and does not reflect the order of
+    attributes as found in an input document.
+    """
+
+    def __init__(self, attrs, attrsNS, ownerElement):
+        self._attrs = attrs
+        self._attrsNS = attrsNS
+        self._ownerElement = ownerElement
+
+    try:
+        property
+    except NameError:
+        def __getattr__(self, name):
+            if name == "length":
+                return len(self._attrs)
+            raise AttributeError, name
+    else:
+        length = property(lambda self: len(self._attrs),
+                          doc="Number of nodes in the NamedNodeMap.")
+
+    def item(self, index):
+        try:
+            return self[self._attrs.keys()[index]]
+        except IndexError:
+            return None
+
+    def items(self):
+        L = []
+        for node in self._attrs.values():
+            L.append((node.nodeName, node.value))
+        return L
+
+    def itemsNS(self):
+        L = []
+        for node in self._attrs.values():
+            L.append(((node.namespaceURI, node.localName), node.value))
+        return L
+
+    def keys(self):
+        return self._attrs.keys()
+
+    def keysNS(self):
+        return self._attrsNS.keys()
+
+    def values(self):
+        return self._attrs.values()
+
+    def get(self, name, value = None):
+        return self._attrs.get(name, value)
+
+    def __len__(self):
+        return self.length
+
+    def __cmp__(self, other):
+        if self._attrs is getattr(other, "_attrs", None):
+            return 0
+        else:
+            return cmp(id(self), id(other))
+
+    #FIXME: is it appropriate to return .value?
+    def __getitem__(self, attname_or_tuple):
+        if type(attname_or_tuple) is _TupleType:
+            return self._attrsNS[attname_or_tuple]
+        else:
+            return self._attrs[attname_or_tuple]
+
+    # same as set
+    def __setitem__(self, attname, value):
+        if type(value) in _StringTypes:
+            node = Attr(attname)
+            node.value = value
+            node.ownerDocument = self._ownerElement.ownerDocument
+        else:
+            if not isinstance(value, Attr):
+                raise TypeError, "value must be a string or Attr object"
+            node = value
+        self.setNamedItem(node)
+
+    def setNamedItem(self, node):
+        if not isinstance(node, Attr):
+            raise HierarchyRequestErr, \
+                  "%s cannot be child of %s" % (repr(node), repr(self))
+        old = self._attrs.get(node.name)
+        if old:
+            old.unlink()
+        self._attrs[node.name] = node
+        self._attrsNS[(node.namespaceURI, node.localName)] = node
+        node.ownerElement = self._ownerElement
+        return old
+
+    def setNamedItemNS(self, node):
+        return self.setNamedItem(node)
+
+    def __delitem__(self, attname_or_tuple):
+        node = self[attname_or_tuple]
+        node.unlink()
+        del self._attrs[node.name]
+        del self._attrsNS[(node.namespaceURI, node.localName)]
+        self.length = len(self._attrs)
+
+AttributeList = NamedNodeMap
+
+
+class Element(Node):
+    nodeType = Node.ELEMENT_NODE
+    nextSibling = None
+    previousSibling = None
+    childNodeTypes = (Node.ELEMENT_NODE, Node.PROCESSING_INSTRUCTION_NODE,
+                      Node.COMMENT_NODE, Node.TEXT_NODE,
+                      Node.CDATA_SECTION_NODE, Node.ENTITY_REFERENCE_NODE)
+
+    def __init__(self, tagName, namespaceURI=EMPTY_NAMESPACE, prefix=None,
+                 localName=None):
+        Node.__init__(self)
+        self.tagName = self.nodeName = tagName
+        self.localName = localName or tagName
+        self.prefix = prefix
+        self.namespaceURI = namespaceURI
+        self.nodeValue = None
+
+        self._attrs = {}   # attributes are double-indexed:
+        self._attrsNS = {} #    tagName -> Attribute
+                           #    URI,localName -> Attribute
+                           # in the future: consider lazy generation
+                           # of attribute objects this is too tricky
+                           # for now because of headaches with
+                           # namespaces.
+
+    def cloneNode(self, deep):
+        clone = Node.cloneNode(self, deep)
+        clone._attrs = {}
+        clone._attrsNS = {}
+        for attr in self._attrs.values():
+            node = attr.cloneNode(1)
+            clone._attrs[node.name] = node
+            clone._attrsNS[(node.namespaceURI, node.localName)] = node
+            node.ownerElement = clone
+        return clone
+
+    def unlink(self):
+        for attr in self._attrs.values():
+            attr.unlink()
+        self._attrs = None
+        self._attrsNS = None
+        Node.unlink(self)
+
+    def getAttribute(self, attname):
+        try:
+            return self._attrs[attname].value
+        except KeyError:
+            return ""
+
+    def getAttributeNS(self, namespaceURI, localName):
+        try:
+            return self._attrsNS[(namespaceURI, localName)].value
+        except KeyError:
+            return ""
+
+    def setAttribute(self, attname, value):
+        attr = Attr(attname)
+        # for performance
+        d = attr.__dict__
+        d["value"] = d["nodeValue"] = value
+        d["ownerDocument"] = self.ownerDocument
+        self.setAttributeNode(attr)
+
+    def setAttributeNS(self, namespaceURI, qualifiedName, value):
+        prefix, localname = _nssplit(qualifiedName)
+        # for performance
+        attr = Attr(qualifiedName, namespaceURI, localname, prefix)
+        d = attr.__dict__
+        d["value"] = d["nodeValue"] = value
+        d["ownerDocument"] = self.ownerDocument
+        self.setAttributeNode(attr)
+
+    def getAttributeNode(self, attrname):
+        return self._attrs.get(attrname)
+
+    def getAttributeNodeNS(self, namespaceURI, localName):
+        return self._attrsNS.get((namespaceURI, localName))
+
+    def setAttributeNode(self, attr):
+        if attr.ownerElement not in (None, self):
+            raise xml.dom.InuseAttributeErr("attribute node already owned")
+        old = self._attrs.get(attr.name, None)
+        if old:
+            old.unlink()
+        self._attrs[attr.name] = attr
+        self._attrsNS[(attr.namespaceURI, attr.localName)] = attr
+
+        # This creates a circular reference, but Element.unlink()
+        # breaks the cycle since the references to the attribute
+        # dictionaries are tossed.
+        attr.ownerElement = self
+
+        if old is not attr:
+            # It might have already been part of this node, in which case
+            # it doesn't represent a change, and should not be returned.
+            return old
+
+    setAttributeNodeNS = setAttributeNode
+
+    def removeAttribute(self, name):
+        attr = self._attrs[name]
+        self.removeAttributeNode(attr)
+
+    def removeAttributeNS(self, namespaceURI, localName):
+        attr = self._attrsNS[(namespaceURI, localName)]
+        self.removeAttributeNode(attr)
+
+    def removeAttributeNode(self, node):
+        node.unlink()
+        del self._attrs[node.name]
+        del self._attrsNS[(node.namespaceURI, node.localName)]
+
+    removeAttributeNodeNS = removeAttributeNode
+
+    def hasAttribute(self, name):
+        return self._attrs.has_key(name)
+
+    def hasAttributeNS(self, namespaceURI, localName):
+        return self._attrsNS.has_key((namespaceURI, localName))
+
+    def getElementsByTagName(self, name):
+        return _getElementsByTagNameHelper(self, name, NodeList())
+
+    def getElementsByTagNameNS(self, namespaceURI, localName):
+        return _getElementsByTagNameNSHelper(self, namespaceURI, localName,
+                                             NodeList())
+
+    def __repr__(self):
+        return "<DOM Element: %s at %s>" % (self.tagName, id(self))
+
+    def writexml(self, writer, indent="", addindent="", newl=""):
+        # indent = current indentation
+        # addindent = indentation to add to higher levels
+        # newl = newline string
+        writer.write(indent+"<" + self.tagName)
+
+        attrs = self._get_attributes()
+        a_names = attrs.keys()
+        a_names.sort()
+
+        for a_name in a_names:
+            writer.write(" %s=\"" % a_name)
+            _write_data(writer, attrs[a_name].value)
+            writer.write("\"")
+        if self.childNodes:
+            writer.write(">%s"%(newl))
+            for node in self.childNodes:
+                node.writexml(writer,indent+addindent,addindent,newl)
+            writer.write("%s</%s>%s" % (indent,self.tagName,newl))
+        else:
+            writer.write("/>%s"%(newl))
+
+    def _get_attributes(self):
+        return NamedNodeMap(self._attrs, self._attrsNS, self)
+
+    try:
+        property
+    except NameError:
+        pass
+    else:
+        attributes = property(_get_attributes,
+                              doc="NamedNodeMap of attributes on the element.")
+
+    def hasAttributes(self):
+        if self._attrs or self._attrsNS:
+            return 1
+        else:
+            return 0
+
+class Comment(Node):
+    nodeType = Node.COMMENT_NODE
+    nodeName = "#comment"
+    attributes = None
+    childNodeTypes = ()
+
+    def __init__(self, data):
+        Node.__init__(self)
+        self.data = self.nodeValue = data
+
+    def writexml(self, writer, indent="", addindent="", newl=""):
+        writer.write("%s<!--%s-->%s" % (indent,self.data,newl))
+
+class ProcessingInstruction(Node):
+    nodeType = Node.PROCESSING_INSTRUCTION_NODE
+    attributes = None
+    childNodeTypes = ()
+
+    def __init__(self, target, data):
+        Node.__init__(self)
+        self.target = self.nodeName = target
+        self.data = self.nodeValue = data
+
+    def writexml(self, writer, indent="", addindent="", newl=""):
+        writer.write("%s<?%s %s?>%s" % (indent,self.target, self.data, newl))
+
+class CharacterData(Node):
+    def __init__(self, data):
+        if type(data) not in _StringTypes:
+            raise TypeError, "node contents must be a string"
+        Node.__init__(self)
+        self.data = self.nodeValue = data
+        self.length = len(data)
+
+    def __repr__(self):
+        if len(self.data) > 10:
+            dotdotdot = "..."
+        else:
+            dotdotdot = ""
+        return "<DOM %s node \"%s%s\">" % (
+            self.__class__.__name__, self.data[0:10], dotdotdot)
+
+    def substringData(self, offset, count):
+        if offset < 0:
+            raise xml.dom.IndexSizeErr("offset cannot be negative")
+        if offset >= len(self.data):
+            raise xml.dom.IndexSizeErr("offset cannot be beyond end of data")
+        if count < 0:
+            raise xml.dom.IndexSizeErr("count cannot be negative")
+        return self.data[offset:offset+count]
+
+    def appendData(self, arg):
+        self.data = self.data + arg
+        self.nodeValue = self.data
+        self.length = len(self.data)
+
+    def insertData(self, offset, arg):
+        if offset < 0:
+            raise xml.dom.IndexSizeErr("offset cannot be negative")
+        if offset >= len(self.data):
+            raise xml.dom.IndexSizeErr("offset cannot be beyond end of data")
+        if arg:
+            self.data = "%s%s%s" % (
+                self.data[:offset], arg, self.data[offset:])
+            self.nodeValue = self.data
+            self.length = len(self.data)
+
+    def deleteData(self, offset, count):
+        if offset < 0:
+            raise xml.dom.IndexSizeErr("offset cannot be negative")
+        if offset >= len(self.data):
+            raise xml.dom.IndexSizeErr("offset cannot be beyond end of data")
+        if count < 0:
+            raise xml.dom.IndexSizeErr("count cannot be negative")
+        if count:
+            self.data = self.data[:offset] + self.data[offset+count:]
+            self.nodeValue = self.data
+            self.length = len(self.data)
+
+    def replaceData(self, offset, count, arg):
+        if offset < 0:
+            raise xml.dom.IndexSizeErr("offset cannot be negative")
+        if offset >= len(self.data):
+            raise xml.dom.IndexSizeErr("offset cannot be beyond end of data")
+        if count < 0:
+            raise xml.dom.IndexSizeErr("count cannot be negative")
+        if count:
+            self.data = "%s%s%s" % (
+                self.data[:offset], arg, self.data[offset+count:])
+            self.nodeValue = self.data
+            self.length = len(self.data)
+
+class Text(CharacterData):
+    nodeType = Node.TEXT_NODE
+    nodeName = "#text"
+    attributes = None
+    childNodeTypes = ()
+
+    def splitText(self, offset):
+        if offset < 0 or offset > len(self.data):
+            raise xml.dom.IndexSizeErr("illegal offset value")
+        newText = Text(self.data[offset:])
+        next = self.nextSibling
+        if self.parentNode and self in self.parentNode.childNodes:
+            if next is None:
+                self.parentNode.appendChild(newText)
+            else:
+                self.parentNode.insertBefore(newText, next)
+        self.data = self.data[:offset]
+        self.nodeValue = self.data
+        self.length = len(self.data)
+        return newText
+
+    def writexml(self, writer, indent="", addindent="", newl=""):
+        _write_data(writer, "%s%s%s"%(indent, self.data, newl))
+
+
+class CDATASection(Text):
+    nodeType = Node.CDATA_SECTION_NODE
+    nodeName = "#cdata-section"
+
+    def writexml(self, writer, indent="", addindent="", newl=""):
+        writer.write("<![CDATA[%s]]>" % self.data)
+
+
+def _nssplit(qualifiedName):
+    fields = _string.split(qualifiedName, ':', 1)
+    if len(fields) == 2:
+        return fields
+    elif len(fields) == 1:
+        return (None, fields[0])
+
+
+class DocumentType(Node):
+    nodeType = Node.DOCUMENT_TYPE_NODE
+    nodeValue = None
+    attributes = None
+    name = None
+    publicId = None
+    systemId = None
+    internalSubset = None
+    entities = None
+    notations = None
+
+    def __init__(self, qualifiedName):
+        Node.__init__(self)
+        if qualifiedName:
+            prefix, localname = _nssplit(qualifiedName)
+            self.name = localname
+
+
+class DOMImplementation:
+    def hasFeature(self, feature, version):
+        if version not in ("1.0", "2.0"):
+            return 0
+        feature = _string.lower(feature)
+        return feature == "core"
+
+    def createDocument(self, namespaceURI, qualifiedName, doctype):
+        if doctype and doctype.parentNode is not None:
+            raise xml.dom.WrongDocumentErr(
+                "doctype object owned by another DOM tree")
+        doc = self._createDocument()
+        if doctype is None:
+            doctype = self.createDocumentType(qualifiedName, None, None)
+        if not qualifiedName:
+            # The spec is unclear what to raise here; SyntaxErr
+            # would be the other obvious candidate. Since Xerces raises
+            # InvalidCharacterErr, and since SyntaxErr is not listed
+            # for createDocument, that seems to be the better choice.
+            # XXX: need to check for illegal characters here and in
+            # createElement.
+            raise xml.dom.InvalidCharacterErr("Element with no name")
+        prefix, localname = _nssplit(qualifiedName)
+        if prefix == "xml" \
+           and namespaceURI != "http://www.w3.org/XML/1998/namespace":
+            raise xml.dom.NamespaceErr("illegal use of 'xml' prefix")
+        if prefix and not namespaceURI:
+            raise xml.dom.NamespaceErr(
+                "illegal use of prefix without namespaces")
+        element = doc.createElementNS(namespaceURI, qualifiedName)
+        doc.appendChild(element)
+        doctype.parentNode = doctype.ownerDocument = doc
+        doc.doctype = doctype
+        doc.implementation = self
+        return doc
+
+    def createDocumentType(self, qualifiedName, publicId, systemId):
+        doctype = DocumentType(qualifiedName)
+        doctype.publicId = publicId
+        doctype.systemId = systemId
+        return doctype
+
+    # internal
+    def _createDocument(self):
+        return Document()
+
+class Document(Node):
+    nodeType = Node.DOCUMENT_NODE
+    nodeName = "#document"
+    nodeValue = None
+    attributes = None
+    doctype = None
+    parentNode = None
+    previousSibling = nextSibling = None
+
+    implementation = DOMImplementation()
+    childNodeTypes = (Node.ELEMENT_NODE, Node.PROCESSING_INSTRUCTION_NODE,
+                      Node.COMMENT_NODE, Node.DOCUMENT_TYPE_NODE)
+
+    def appendChild(self, node):
+        if node.nodeType not in self.childNodeTypes:
+            raise HierarchyRequestErr, \
+                  "%s cannot be child of %s" % (repr(node), repr(self))
+        if node.parentNode is not None:
+            node.parentNode.removeChild(node)
+
+        if node.nodeType == Node.ELEMENT_NODE \
+           and self._get_documentElement():
+            raise xml.dom.HierarchyRequestErr(
+                "two document elements disallowed")
+        return Node.appendChild(self, node)
+
+    def removeChild(self, oldChild):
+        self.childNodes.remove(oldChild)
+        oldChild.nextSibling = oldChild.previousSibling = None
+        oldChild.parentNode = None
+        if self.documentElement is oldChild:
+            self.documentElement = None
+
+        return oldChild
+
+    def _get_documentElement(self):
+        for node in self.childNodes:
+            if node.nodeType == Node.ELEMENT_NODE:
+                return node
+
+    try:
+        property
+    except NameError:
+        pass
+    else:
+        documentElement = property(_get_documentElement,
+                                   doc="Top-level element of this document.")
+
+    def unlink(self):
+        if self.doctype is not None:
+            self.doctype.unlink()
+            self.doctype = None
+        Node.unlink(self)
+
+    def createDocumentFragment(self):
+        d = DocumentFragment()
+        d.ownerDoc = self
+        return d
+
+    def createElement(self, tagName):
+        e = Element(tagName)
+        e.ownerDocument = self
+        return e
+
+    def createTextNode(self, data):
+        t = Text(data)
+        t.ownerDocument = self
+        return t
+
+    def createCDATASection(self, data):
+        c = CDATASection(data)
+        c.ownerDocument = self
+        return c
+
+    def createComment(self, data):
+        c = Comment(data)
+        c.ownerDocument = self
+        return c
+
+    def createProcessingInstruction(self, target, data):
+        p = ProcessingInstruction(target, data)
+        p.ownerDocument = self
+        return p
+
+    def createAttribute(self, qName):
+        a = Attr(qName)
+        a.ownerDocument = self
+        a.value = ""
+        return a
+
+    def createElementNS(self, namespaceURI, qualifiedName):
+        prefix, localName = _nssplit(qualifiedName)
+        e = Element(qualifiedName, namespaceURI, prefix, localName)
+        e.ownerDocument = self
+        return e
+
+    def createAttributeNS(self, namespaceURI, qualifiedName):
+        prefix, localName = _nssplit(qualifiedName)
+        a = Attr(qualifiedName, namespaceURI, localName, prefix)
+        a.ownerDocument = self
+        a.value = ""
+        return a
+
+    def getElementsByTagName(self, name):
+        return _getElementsByTagNameHelper(self, name, NodeList())
+
+    def getElementsByTagNameNS(self, namespaceURI, localName):
+        return _getElementsByTagNameNSHelper(self, namespaceURI, localName,
+                                             NodeList())
+
+    def writexml(self, writer, indent="", addindent="", newl=""):
+        writer.write('<?xml version="1.0" ?>\n')
+        for node in self.childNodes:
+            node.writexml(writer, indent, addindent, newl)
+
+def _get_StringIO():
+    # we can't use cStringIO since it doesn't support Unicode strings
+    from StringIO import StringIO
+    return StringIO()
+
+def _doparse(func, args, kwargs):
+    events = apply(func, args, kwargs)
+    toktype, rootNode = events.getEvent()
+    events.expandNode(rootNode)
+    events.clear()
+    return rootNode
+
+def parse(*args, **kwargs):
+    """Parse a file into a DOM by filename or file object."""
+    from xml.dom import pulldom
+    return _doparse(pulldom.parse, args, kwargs)
+
+def parseString(*args, **kwargs):
+    """Parse a file into a DOM from a string."""
+    from xml.dom import pulldom
+    return _doparse(pulldom.parseString, args, kwargs)
+
+def getDOMImplementation():
+    return Document.implementation
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/python-lib/xml/dom/pulldom.py pyexpat-2.2.3-patched/python-lib/xml/dom/pulldom.py
--- pyexpat-2.2.3-orig/python-lib/xml/dom/pulldom.py	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/python-lib/xml/dom/pulldom.py	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,341 @@
+import xml.sax
+import xml.sax.handler
+import types
+
+try:
+    _StringTypes = [types.StringType, types.UnicodeType]
+except AttributeError:
+    _StringTypes = [types.StringType]
+
+START_ELEMENT = "START_ELEMENT"
+END_ELEMENT = "END_ELEMENT"
+COMMENT = "COMMENT"
+START_DOCUMENT = "START_DOCUMENT"
+END_DOCUMENT = "END_DOCUMENT"
+PROCESSING_INSTRUCTION = "PROCESSING_INSTRUCTION"
+IGNORABLE_WHITESPACE = "IGNORABLE_WHITESPACE"
+CHARACTERS = "CHARACTERS"
+
+class PullDOM(xml.sax.ContentHandler):
+    _locator = None
+    document = None
+
+    def __init__(self, documentFactory=None):
+        self.documentFactory = documentFactory
+        self.firstEvent = [None, None]
+        self.lastEvent = self.firstEvent
+        self.elementStack = []
+        self.push = self.elementStack.append
+        try:
+            self.pop = self.elementStack.pop
+        except AttributeError:
+            # use class' pop instead
+            pass
+        self._ns_contexts = [{}] # contains uri -> prefix dicts
+        self._current_context = self._ns_contexts[-1]
+        self.pending_events = []
+
+    def pop(self):
+        result = self.elementStack[-1]
+        del self.elementStack[-1]
+        return result
+
+    def setDocumentLocator(self, locator):
+        self._locator = locator
+
+    def startPrefixMapping(self, prefix, uri):
+        if not hasattr(self, '_xmlns_attrs'):
+            self._xmlns_attrs = []
+        self._xmlns_attrs.append((prefix or 'xmlns', uri))
+        self._ns_contexts.append(self._current_context.copy())
+        self._current_context[uri] = prefix or None
+
+    def endPrefixMapping(self, prefix):
+        self._current_context = self._ns_contexts.pop()
+
+    def startElementNS(self, name, tagName , attrs):
+        # Retrieve xml namespace declaration attributes.
+        xmlns_uri = 'http://www.w3.org/2000/xmlns/'
+        xmlns_attrs = getattr(self, '_xmlns_attrs', None)
+        if xmlns_attrs is not None:
+            for aname, value in xmlns_attrs:
+                attrs._attrs[(xmlns_uri, aname)] = value
+            self._xmlns_attrs = []
+        uri, localname = name
+        if uri:
+            # When using namespaces, the reader may or may not
+            # provide us with the original name. If not, create
+            # *a* valid tagName from the current context.
+            if tagName is None:
+                prefix = self._current_context[uri]
+                if prefix:
+                    tagName = prefix + ":" + localname
+                else:
+                    tagName = localname
+            if self.document:
+                node = self.document.createElementNS(uri, tagName)
+            else:
+                node = self.buildDocument(uri, tagName)
+        else:
+            # When the tagname is not prefixed, it just appears as
+            # localname
+            if self.document:
+                node = self.document.createElement(localname)
+            else:
+                node = self.buildDocument(None, localname)
+
+        for aname,value in attrs.items():
+            a_uri, a_localname = aname
+            if a_uri == xmlns_uri:
+                if a_localname == 'xmlns':
+                    qname = a_localname
+                else:
+                    qname = 'xmlns:' + a_localname
+                attr = self.document.createAttributeNS(a_uri, qname)
+                node.setAttributeNodeNS(attr)
+            elif a_uri:
+                prefix = self._current_context[a_uri]
+                if prefix:
+                    qname = prefix + ":" + a_localname
+                else:
+                    qname = a_localname
+                attr = self.document.createAttributeNS(a_uri, qname)
+                node.setAttributeNodeNS(attr)
+            else:
+                attr = self.document.createAttribute(a_localname)
+                node.setAttributeNode(attr)
+            attr.value = value
+
+        self.lastEvent[1] = [(START_ELEMENT, node), None]
+        self.lastEvent = self.lastEvent[1]
+        self.push(node)
+
+    def endElementNS(self, name, tagName):
+        self.lastEvent[1] = [(END_ELEMENT, self.pop()), None]
+        self.lastEvent = self.lastEvent[1]
+
+    def startElement(self, name, attrs):
+        if self.document:
+            node = self.document.createElement(name)
+        else:
+            node = self.buildDocument(None, name)
+
+        for aname,value in attrs.items():
+            attr = self.document.createAttribute(aname)
+            attr.value = value
+            node.setAttributeNode(attr)
+
+        self.lastEvent[1] = [(START_ELEMENT, node), None]
+        self.lastEvent = self.lastEvent[1]
+        self.push(node)
+
+    def endElement(self, name):
+        self.lastEvent[1] = [(END_ELEMENT, self.pop()), None]
+        self.lastEvent = self.lastEvent[1]
+
+    def comment(self, s):
+        if self.document:
+            node = self.document.createComment(s)
+            self.lastEvent[1] = [(COMMENT, node), None]
+            self.lastEvent = self.lastEvent[1]
+        else:
+            event = [(COMMENT, s), None]
+            self.pending_events.append(event)
+
+    def processingInstruction(self, target, data):
+        if self.document:
+            node = self.document.createProcessingInstruction(target, data)
+            self.lastEvent[1] = [(PROCESSING_INSTRUCTION, node), None]
+            self.lastEvent = self.lastEvent[1]
+        else:
+            event = [(PROCESSING_INSTRUCTION, target, data), None]
+            self.pending_events.append(event)
+
+    def ignorableWhitespace(self, chars):
+        node = self.document.createTextNode(chars)
+        self.lastEvent[1] = [(IGNORABLE_WHITESPACE, node), None]
+        self.lastEvent = self.lastEvent[1]
+
+    def characters(self, chars):
+        node = self.document.createTextNode(chars)
+        self.lastEvent[1] = [(CHARACTERS, node), None]
+        self.lastEvent = self.lastEvent[1]
+
+    def startDocument(self):
+        if self.documentFactory is None:
+            import xml.dom.minidom
+            self.documentFactory = xml.dom.minidom.Document.implementation
+
+    def buildDocument(self, uri, tagname):
+        # Can't do that in startDocument, since we need the tagname
+        # XXX: obtain DocumentType
+        node = self.documentFactory.createDocument(uri, tagname, None)
+        self.document = node
+        self.lastEvent[1] = [(START_DOCUMENT, node), None]
+        self.lastEvent = self.lastEvent[1]
+        self.push(node)
+        # Put everything we have seen so far into the document
+        for e in self.pending_events:
+            if e[0][0] == PROCESSING_INSTRUCTION:
+                _,target,data = e[0]
+                n = self.document.createProcessingInstruction(target, data)
+                e[0] = (PROCESSING_INSTRUCTION, n)
+            elif e[0][0] == COMMENT:
+                n = self.document.createComment(e[0][1])
+                e[0] = (COMMENT, n)
+            else:
+                raise AssertionError("Unknown pending event ",e[0][0])
+            self.lastEvent[1] = e
+            self.lastEvent = e
+        self.pending_events = None
+        return node.firstChild
+
+    def endDocument(self):
+        self.lastEvent[1] = [(END_DOCUMENT, self.document), None]
+        self.pop()
+
+    def clear(self):
+        "clear(): Explicitly release parsing structures"
+        self.document = None
+
+class ErrorHandler:
+    def warning(self, exception):
+        print exception
+    def error(self, exception):
+        raise exception
+    def fatalError(self, exception):
+        raise exception
+
+class DOMEventStream:
+    def __init__(self, stream, parser, bufsize):
+        self.stream = stream
+        self.parser = parser
+        self.bufsize = bufsize
+        if not hasattr(self.parser, 'feed'):
+            self.getEvent = self._slurp
+        self.reset()
+
+    def reset(self):
+        self.pulldom = PullDOM()
+        # This content handler relies on namespace support
+        self.parser.setFeature(xml.sax.handler.feature_namespaces, 1)
+        self.parser.setContentHandler(self.pulldom)
+
+    def __getitem__(self, pos):
+        rc = self.getEvent()
+        if rc:
+            return rc
+        raise IndexError
+
+    def expandNode(self, node):
+        event = self.getEvent()
+        parents = [node]
+        while event:
+            token, cur_node = event
+            if cur_node is node:
+                return
+            if token != END_ELEMENT:
+                parents[-1].appendChild(cur_node)
+            if token == START_ELEMENT:
+                parents.append(cur_node)
+            elif token == END_ELEMENT:
+                del parents[-1]
+            event = self.getEvent()
+
+    def getEvent(self):
+        # use IncrementalParser interface, so we get the desired
+        # pull effect
+        if not self.pulldom.firstEvent[1]:
+            self.pulldom.lastEvent = self.pulldom.firstEvent
+        while not self.pulldom.firstEvent[1]:
+            buf = self.stream.read(self.bufsize)
+            if not buf:
+                self.parser.close()
+                return None
+            self.parser.feed(buf)
+        rc = self.pulldom.firstEvent[1][0]
+        self.pulldom.firstEvent[1] = self.pulldom.firstEvent[1][1]
+        return rc
+
+    def _slurp(self):
+        """ Fallback replacement for getEvent() using the
+            standard SAX2 interface, which means we slurp the
+            SAX events into memory (no performance gain, but
+            we are compatible to all SAX parsers).
+        """
+        self.parser.parse(self.stream)
+        self.getEvent = self._emit
+        return self._emit()
+
+    def _emit(self):
+        """ Fallback replacement for getEvent() that emits
+            the events that _slurp() read previously.
+        """
+        rc = self.pulldom.firstEvent[1][0]
+        self.pulldom.firstEvent[1] = self.pulldom.firstEvent[1][1]
+        return rc
+
+    def clear(self):
+        """clear(): Explicitly release parsing objects"""
+        self.pulldom.clear()
+        del self.pulldom
+        self.parser = None
+        self.stream = None
+
+class SAX2DOM(PullDOM):
+
+    def startElementNS(self, name, tagName , attrs):
+        PullDOM.startElementNS(self, name, tagName, attrs)
+        curNode = self.elementStack[-1]
+        parentNode = self.elementStack[-2]
+        parentNode.appendChild(curNode)
+
+    def startElement(self, name, attrs):
+        PullDOM.startElement(self, name, attrs)
+        curNode = self.elementStack[-1]
+        parentNode = self.elementStack[-2]
+        parentNode.appendChild(curNode)
+
+    def processingInstruction(self, target, data):
+        PullDOM.processingInstruction(self, target, data)
+        node = self.lastEvent[0][1]
+        parentNode = self.elementStack[-1]
+        parentNode.appendChild(node)
+
+    def ignorableWhitespace(self, chars):
+        PullDOM.ignorableWhitespace(self, chars)
+        node = self.lastEvent[0][1]
+        parentNode = self.elementStack[-1]
+        parentNode.appendChild(node)
+
+    def characters(self, chars):
+        PullDOM.characters(self, chars)
+        node = self.lastEvent[0][1]
+        parentNode = self.elementStack[-1]
+        parentNode.appendChild(node)
+
+
+default_bufsize = (2 ** 14) - 20
+
+def parse(stream_or_string, parser=None, bufsize=None):
+    if bufsize is None:
+        bufsize = default_bufsize
+    if type(stream_or_string) in _StringTypes:
+        stream = open(stream_or_string)
+    else:
+        stream = stream_or_string
+    if not parser:
+        parser = xml.sax.make_parser()
+    return DOMEventStream(stream, parser, bufsize)
+
+def parseString(string, parser=None):
+    try:
+        from cStringIO import StringIO
+    except ImportError:
+        from StringIO import StringIO
+
+    bufsize = len(string)
+    buf = StringIO(string)
+    if not parser:
+        parser = xml.sax.make_parser()
+    return DOMEventStream(buf, parser, bufsize)
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/python-lib/xml/parsers/__init__.py pyexpat-2.2.3-patched/python-lib/xml/parsers/__init__.py
--- pyexpat-2.2.3-orig/python-lib/xml/parsers/__init__.py	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/python-lib/xml/parsers/__init__.py	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,8 @@
+"""Python interfaces to XML parsers.
+
+This package contains one module:
+
+expat -- Python wrapper for James Clark's Expat parser, with namespace
+         support.
+
+"""
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/python-lib/xml/parsers/expat.py pyexpat-2.2.3-patched/python-lib/xml/parsers/expat.py
--- pyexpat-2.2.3-orig/python-lib/xml/parsers/expat.py	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/python-lib/xml/parsers/expat.py	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,13 @@
+"""Interface to the Expat non-validating XML parser."""
+__version__ = '$Revision: 1.1.26.1 $'
+
+import sys
+
+try:
+    from pyexpat import *
+except ImportError:
+    del sys.modules[__name__]
+    del sys
+    raise
+
+del sys
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/python-lib/xml/sax/__init__.py pyexpat-2.2.3-patched/python-lib/xml/sax/__init__.py
--- pyexpat-2.2.3-orig/python-lib/xml/sax/__init__.py	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/python-lib/xml/sax/__init__.py	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,108 @@
+"""Simple API for XML (SAX) implementation for Python.
+
+This module provides an implementation of the SAX 2 interface;
+information about the Java version of the interface can be found at
+http://www.megginson.com/SAX/.  The Python version of the interface is
+documented at <...>.
+
+This package contains the following modules:
+
+handler -- Base classes and constants which define the SAX 2 API for
+           the 'client-side' of SAX for Python.
+
+saxutils -- Implementation of the convenience classes commonly used to
+            work with SAX.
+
+xmlreader -- Base classes and constants which define the SAX 2 API for
+             the parsers used with SAX for Python.
+
+expatreader -- Driver that allows use of the Expat parser with SAX.
+"""
+
+from xmlreader import InputSource
+from handler import ContentHandler, ErrorHandler
+from _exceptions import SAXException, SAXNotRecognizedException, \
+                        SAXParseException, SAXNotSupportedException, \
+                        SAXReaderNotAvailable
+
+
+def parse(source, handler, errorHandler=ErrorHandler()):
+    parser = make_parser()
+    parser.setContentHandler(handler)
+    parser.setErrorHandler(errorHandler)
+    parser.parse(source)
+
+def parseString(string, handler, errorHandler=ErrorHandler()):
+    try:
+        from cStringIO import StringIO
+    except ImportError:
+        from StringIO import StringIO
+
+    if errorHandler is None:
+        errorHandler = ErrorHandler()
+    parser = make_parser()
+    parser.setContentHandler(handler)
+    parser.setErrorHandler(errorHandler)
+
+    inpsrc = InputSource()
+    inpsrc.setByteStream(StringIO(string))
+    parser.parse(inpsrc)
+
+# this is the parser list used by the make_parser function if no
+# alternatives are given as parameters to the function
+
+default_parser_list = ["xml.sax.expatreader"]
+
+# tell modulefinder that importing sax potentially imports expatreader
+_false = 0
+if _false:
+    import xml.sax.expatreader
+
+import os, string, sys
+if os.environ.has_key("PY_SAX_PARSER"):
+    default_parser_list = string.split(os.environ["PY_SAX_PARSER"], ",")
+del os
+
+_key = "python.xml.sax.parser"
+if sys.platform[:4] == "java" and sys.registry.containsKey(_key):
+    default_parser_list = string.split(sys.registry.getProperty(_key), ",")
+
+
+def make_parser(parser_list = []):
+    """Creates and returns a SAX parser.
+
+    Creates the first parser it is able to instantiate of the ones
+    given in the list created by doing parser_list +
+    default_parser_list.  The lists must contain the names of Python
+    modules containing both a SAX parser and a create_parser function."""
+
+    for parser_name in parser_list + default_parser_list:
+        try:
+            return _create_parser(parser_name)
+        except ImportError,e:
+            import sys
+            if sys.modules.has_key(parser_name):
+                # The parser module was found, but importing it
+                # failed unexpectedly, pass this exception through
+                raise
+        except SAXReaderNotAvailable:
+            # The parser module detected that it won't work properly,
+            # so try the next one
+            pass
+
+    raise SAXReaderNotAvailable("No parsers found", None)
+
+# --- Internal utility methods used by make_parser
+
+if sys.platform[ : 4] == "java":
+    def _create_parser(parser_name):
+        from org.python.core import imp
+        drv_module = imp.importName(parser_name, 0, globals())
+        return drv_module.create_parser()
+
+else:
+    def _create_parser(parser_name):
+        drv_module = __import__(parser_name,{},{},['create_parser'])
+        return drv_module.create_parser()
+
+del sys
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/python-lib/xml/sax/_exceptions.py pyexpat-2.2.3-patched/python-lib/xml/sax/_exceptions.py
--- pyexpat-2.2.3-orig/python-lib/xml/sax/_exceptions.py	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/python-lib/xml/sax/_exceptions.py	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,126 @@
+"""Different kinds of SAX Exceptions"""
+import sys
+if sys.platform[:4] == "java":
+    from java.lang import Exception
+del sys
+
+# ===== SAXEXCEPTION =====
+
+class SAXException(Exception):
+    """Encapsulate an XML error or warning. This class can contain
+    basic error or warning information from either the XML parser or
+    the application: you can subclass it to provide additional
+    functionality, or to add localization. Note that although you will
+    receive a SAXException as the argument to the handlers in the
+    ErrorHandler interface, you are not actually required to throw
+    the exception; instead, you can simply read the information in
+    it."""
+
+    def __init__(self, msg, exception=None):
+        """Creates an exception. The message is required, but the exception
+        is optional."""
+        self._msg = msg
+        self._exception = exception
+        Exception.__init__(self, msg)
+
+    def getMessage(self):
+        "Return a message for this exception."
+        return self._msg
+
+    def getException(self):
+        "Return the embedded exception, or None if there was none."
+        return self._exception
+
+    def __str__(self):
+        "Create a string representation of the exception."
+        return self._msg
+
+    def __getitem__(self, ix):
+        """Avoids weird error messages if someone does exception[ix] by
+        mistake, since Exception has __getitem__ defined."""
+        raise AttributeError("__getitem__")
+
+
+# ===== SAXPARSEEXCEPTION =====
+
+class SAXParseException(SAXException):
+    """Encapsulate an XML parse error or warning.
+
+    This exception will include information for locating the error in
+    the original XML document. Note that although the application will
+    receive a SAXParseException as the argument to the handlers in the
+    ErrorHandler interface, the application is not actually required
+    to throw the exception; instead, it can simply read the
+    information in it and take a different action.
+
+    Since this exception is a subclass of SAXException, it inherits
+    the ability to wrap another exception."""
+
+    def __init__(self, msg, exception, locator):
+        "Creates the exception. The exception parameter is allowed to be None."
+        SAXException.__init__(self, msg, exception)
+        self._locator = locator
+
+        # We need to cache this stuff at construction time.
+        # If this exception is thrown, the objects through which we must
+        # traverse to get this information may be deleted by the time
+        # it gets caught.
+        self._systemId = self._locator.getSystemId()
+        self._colnum = self._locator.getColumnNumber()
+        self._linenum = self._locator.getLineNumber()
+
+    def getColumnNumber(self):
+        """The column number of the end of the text where the exception
+        occurred."""
+        return self._colnum
+
+    def getLineNumber(self):
+        "The line number of the end of the text where the exception occurred."
+        return self._linenum
+
+    def getPublicId(self):
+        "Get the public identifier of the entity where the exception occurred."
+        return self._locator.getPublicId()
+
+    def getSystemId(self):
+        "Get the system identifier of the entity where the exception occurred."
+        return self._systemId
+
+    def __str__(self):
+        "Create a string representation of the exception."
+        sysid = self.getSystemId()
+        if sysid is None:
+            sysid = "<unknown>"
+        return "%s:%d:%d: %s" % (sysid, self.getLineNumber(),
+                                 self.getColumnNumber(), self._msg)
+
+
+# ===== SAXNOTRECOGNIZEDEXCEPTION =====
+
+class SAXNotRecognizedException(SAXException):
+    """Exception class for an unrecognized identifier.
+
+    An XMLReader will raise this exception when it is confronted with an
+    unrecognized feature or property. SAX applications and extensions may
+    use this class for similar purposes."""
+
+
+# ===== SAXNOTSUPPORTEDEXCEPTION =====
+
+class SAXNotSupportedException(SAXException):
+    """Exception class for an unsupported operation.
+
+    An XMLReader will raise this exception when a service it cannot
+    perform is requested (specifically setting a state or value). SAX
+    applications and extensions may use this class for similar
+    purposes."""
+
+# ===== SAXNOTSUPPORTEDEXCEPTION =====
+
+class SAXReaderNotAvailable(SAXNotSupportedException):
+    """Exception class for a missing driver.
+
+    An XMLReader module (driver) should raise this exception when it
+    is first imported, e.g. when a support module cannot be imported.
+    It also may be raised during parsing, e.g. if executing an external
+    program is not permitted."""
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/python-lib/xml/sax/expatreader.py pyexpat-2.2.3-patched/python-lib/xml/sax/expatreader.py
--- pyexpat-2.2.3-orig/python-lib/xml/sax/expatreader.py	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/python-lib/xml/sax/expatreader.py	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,333 @@
+"""
+SAX driver for the Pyexpat C module.  This driver works with
+pyexpat.__version__ == '2.22'.
+"""
+
+version = "0.20"
+
+from xml.sax._exceptions import *
+
+# xml.parsers.expat does not raise ImportError in Jython
+import sys
+if sys.platform[:4] == "java":
+    raise SAXReaderNotAvailable("expat not available in Java", None)
+del sys
+
+try:
+    from xml.parsers import expat
+except ImportError:
+    raise SAXReaderNotAvailable("expat not supported", None)
+else:
+    if not hasattr(expat, "ParserCreate"):
+        raise SAXReaderNotAvailable("expat not supported", None)
+from xml.sax import xmlreader, saxutils, handler
+
+AttributesImpl = xmlreader.AttributesImpl
+AttributesNSImpl = xmlreader.AttributesNSImpl
+
+import string
+import weakref
+
+# --- ExpatLocator
+
+class ExpatLocator(xmlreader.Locator):
+    """Locator for use with the ExpatParser class.
+
+    This uses a weak reference to the parser object to avoid creating
+    a circular reference between the parser and the content handler.
+    """
+    def __init__(self, parser):
+        self._ref = weakref.ref(parser)
+
+    def getColumnNumber(self):
+        parser = self._ref()
+        if parser is None or parser._parser is None:
+            return None
+        return parser._parser.ErrorColumnNumber
+
+    def getLineNumber(self):
+        parser = self._ref()
+        if parser is None or parser._parser is None:
+            return 1
+        return parser._parser.ErrorLineNumber
+
+    def getPublicId(self):
+        parser = self._ref()
+        if parser is None:
+            return None
+        return parser._source.getPublicId()
+
+    def getSystemId(self):
+        parser = self._ref()
+        if parser is None:
+            return None
+        return parser._source.getSystemId()
+
+
+# --- ExpatParser
+
+class ExpatParser(xmlreader.IncrementalParser, xmlreader.Locator):
+    "SAX driver for the Pyexpat C module."
+
+    def __init__(self, namespaceHandling=0, bufsize=2**16-20):
+        xmlreader.IncrementalParser.__init__(self, bufsize)
+        self._source = xmlreader.InputSource()
+        self._parser = None
+        self._namespaces = namespaceHandling
+        self._lex_handler_prop = None
+        self._parsing = 0
+        self._entity_stack = []
+        self._ns_stack = []
+
+    # XMLReader methods
+
+    def parse(self, source):
+        "Parse an XML document from a URL or an InputSource."
+        source = saxutils.prepare_input_source(source)
+
+        self._source = source
+        self.reset()
+        self._cont_handler.setDocumentLocator(ExpatLocator(self))
+        xmlreader.IncrementalParser.parse(self, source)
+
+    def prepareParser(self, source):
+        if source.getSystemId() != None:
+            self._parser.SetBase(source.getSystemId())
+
+    # Redefined setContentHandle to allow changing handlers during parsing
+
+    def setContentHandler(self, handler):
+        xmlreader.IncrementalParser.setContentHandler(self, handler)
+        if self._parsing:
+            self._reset_cont_handler()
+
+    def getFeature(self, name):
+        if name == handler.feature_namespaces:
+            return self._namespaces
+        raise SAXNotRecognizedException("Feature '%s' not recognized" % name)
+
+    def setFeature(self, name, state):
+        if self._parsing:
+            raise SAXNotSupportedException("Cannot set features while parsing")
+        if name == handler.feature_namespaces:
+            self._namespaces = state
+        else:
+            raise SAXNotRecognizedException("Feature '%s' not recognized" %
+                                            name)
+
+    def getProperty(self, name):
+        if name == handler.property_lexical_handler:
+            return self._lex_handler_prop
+        raise SAXNotRecognizedException("Property '%s' not recognized" % name)
+
+    def setProperty(self, name, value):
+        if name == handler.property_lexical_handler:
+            self._lex_handler_prop = value
+            if self._parsing:
+                self._reset_lex_handler_prop()
+        else:
+            raise SAXNotRecognizedException("Property '%s' not recognized" % name)
+
+    # IncrementalParser methods
+
+    def feed(self, data, isFinal = 0):
+        if not self._parsing:
+            self.reset()
+            self._parsing = 1
+            self._cont_handler.startDocument()
+
+        try:
+            # The isFinal parameter is internal to the expat reader.
+            # If it is set to true, expat will check validity of the entire
+            # document. When feeding chunks, they are not normally final -
+            # except when invoked from close.
+            self._parser.Parse(data, isFinal)
+        except expat.error:
+            error_code = self._parser.ErrorCode
+            exc = SAXParseException(expat.ErrorString(error_code), None, self)
+            # FIXME: when to invoke error()?
+            self._err_handler.fatalError(exc)
+
+    def close(self):
+        if self._entity_stack:
+            # If we are completing an external entity, do nothing here
+            return
+        self.feed("", isFinal = 1)
+        self._cont_handler.endDocument()
+        self._parsing = 0
+        # break cycle created by expat handlers pointing to our methods
+        self._parser = None
+
+    def _reset_cont_handler(self):
+        self._parser.ProcessingInstructionHandler = \
+                                    self._cont_handler.processingInstruction
+        self._parser.CharacterDataHandler = self._cont_handler.characters
+
+    def _reset_lex_handler_prop(self):
+        self._parser.CommentHandler = self._lex_handler_prop.comment
+        self._parser.StartCdataSectionHandler = self._lex_handler_prop.startCDATA
+        self._parser.EndCdataSectionHandler = self._lex_handler_prop.endCDATA
+
+    def reset(self):
+        if self._namespaces:
+            self._parser = expat.ParserCreate(None, " ")
+            self._parser.StartElementHandler = self.start_element_ns
+            self._parser.EndElementHandler = self.end_element_ns
+        else:
+            self._parser = expat.ParserCreate()
+            self._parser.StartElementHandler = self.start_element
+            self._parser.EndElementHandler = self.end_element
+
+        self._reset_cont_handler()
+        self._parser.UnparsedEntityDeclHandler = self.unparsed_entity_decl
+        self._parser.NotationDeclHandler = self.notation_decl
+        self._parser.StartNamespaceDeclHandler = self.start_namespace_decl
+        self._parser.EndNamespaceDeclHandler = self.end_namespace_decl
+
+        self._decl_handler_prop = None
+        if self._lex_handler_prop:
+            self._reset_lex_handler_prop()
+#         self._parser.DefaultHandler =
+#         self._parser.DefaultHandlerExpand =
+#         self._parser.NotStandaloneHandler =
+        self._parser.ExternalEntityRefHandler = self.external_entity_ref
+
+        self._parsing = 0
+        self._entity_stack = []
+
+    # Locator methods
+
+    def getColumnNumber(self):
+        if self._parser is None:
+            return None
+        return self._parser.ErrorColumnNumber
+
+    def getLineNumber(self):
+        if self._parser is None:
+            return 1
+        return self._parser.ErrorLineNumber
+
+    def getPublicId(self):
+        return self._source.getPublicId()
+
+    def getSystemId(self):
+        return self._source.getSystemId()
+
+    # event handlers
+    def start_element(self, name, attrs):
+        self._cont_handler.startElement(name, AttributesImpl(attrs))
+
+    def end_element(self, name):
+        self._cont_handler.endElement(name)
+
+    def start_element_ns(self, name, attrs):
+        pair = string.split(name)
+        if len(pair) == 1:
+            pair = (None, name)
+            qname = name
+        else:
+            pair = tuple(pair)
+            qname = pair[1]
+            if self._ns_stack:
+                prefix = self._ns_stack[-1][pair[0]][-1]
+                if prefix:
+                    qname = "%s:%s" % (prefix, pair[1])
+
+        newattrs = {}
+        qnames = {}
+        for (aname, value) in attrs.items():
+            apair = string.split(aname)
+            if len(apair) == 1:
+                apair = (None, aname)
+                aqname = aname
+            else:
+                apair = tuple(apair)
+                # XXX need to guess the prefix
+                prefix = self._ns_stack[-1][apair[0]][-1]
+                aqname = "%s:%s" % (prefix, apair[1])
+
+            newattrs[apair] = value
+            qnames[apair] = aqname
+
+        self._cont_handler.startElementNS(pair, qname,
+                                          AttributesNSImpl(newattrs, qnames))
+
+    def end_element_ns(self, name):
+        pair = string.split(name)
+        if len(pair) == 1:
+            pair = (None, name)
+            qname = name
+        else:
+            pair = tuple(pair)
+            qname = pair[1]
+            if self._ns_stack:
+                prefix = self._ns_stack[-1][pair[0]][-1]
+                if prefix:
+                    qname = "%s:%s" % (prefix, pair[1])
+
+        self._cont_handler.endElementNS(pair, qname)
+
+    # this is not used (call directly to ContentHandler)
+    def processing_instruction(self, target, data):
+        self._cont_handler.processingInstruction(target, data)
+
+    # this is not used (call directly to ContentHandler)
+    def character_data(self, data):
+        self._cont_handler.characters(data)
+
+    def start_namespace_decl(self, prefix, uri):
+        if self._ns_stack:
+            d = self._ns_stack[-1].copy()
+            if d.has_key(uri):
+                L = d[uri][:]
+                d[uri] = L
+                L.append(prefix)
+            else:
+                d[uri] = [prefix]
+        else:
+            d = {uri: [prefix]}
+        self._ns_stack.append(d)
+        self._cont_handler.startPrefixMapping(prefix, uri)
+
+    def end_namespace_decl(self, prefix):
+        del self._ns_stack[-1]
+        self._cont_handler.endPrefixMapping(prefix)
+
+    def unparsed_entity_decl(self, name, base, sysid, pubid, notation_name):
+        self._dtd_handler.unparsedEntityDecl(name, pubid, sysid, notation_name)
+
+    def notation_decl(self, name, base, sysid, pubid):
+        self._dtd_handler.notationDecl(name, pubid, sysid)
+
+    def external_entity_ref(self, context, base, sysid, pubid):
+        source = self._ent_handler.resolveEntity(pubid, sysid)
+        source = saxutils.prepare_input_source(source,
+                                               self._source.getSystemId() or
+                                               "")
+
+        self._entity_stack.append((self._parser, self._source))
+        self._parser = self._parser.ExternalEntityParserCreate(context)
+        self._source = source
+
+        try:
+            xmlreader.IncrementalParser.parse(self, source)
+        except:
+            return 0  # FIXME: save error info here?
+
+        (self._parser, self._source) = self._entity_stack[-1]
+        del self._entity_stack[-1]
+        return 1
+
+# ---
+
+def create_parser(*args, **kwargs):
+    return apply(ExpatParser, args, kwargs)
+
+# ---
+
+if __name__ == "__main__":
+    import xml.sax
+    p = create_parser()
+    p.setContentHandler(xml.sax.XMLGenerator())
+    p.setErrorHandler(xml.sax.ErrorHandler())
+    p.parse("../../../hamlet.xml")
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/python-lib/xml/sax/handler.py pyexpat-2.2.3-patched/python-lib/xml/sax/handler.py
--- pyexpat-2.2.3-orig/python-lib/xml/sax/handler.py	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/python-lib/xml/sax/handler.py	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,321 @@
+"""
+This module contains the core classes of version 2.0 of SAX for Python.
+This file provides only default classes with absolutely minimum
+functionality, from which drivers and applications can be subclassed.
+
+Many of these classes are empty and are included only as documentation
+of the interfaces.
+
+$Id: handler.py,v 1.8 2000/10/23 18:09:50 fdrake Exp $
+"""
+
+version = '2.0beta'
+
+#============================================================================
+#
+# HANDLER INTERFACES
+#
+#============================================================================
+
+# ===== ERRORHANDLER =====
+
+class ErrorHandler:
+    """Basic interface for SAX error handlers.
+
+    If you create an object that implements this interface, then
+    register the object with your XMLReader, the parser will call the
+    methods in your object to report all warnings and errors. There
+    are three levels of errors available: warnings, (possibly)
+    recoverable errors, and unrecoverable errors. All methods take a
+    SAXParseException as the only parameter."""
+
+    def error(self, exception):
+        "Handle a recoverable error."
+        raise exception
+
+    def fatalError(self, exception):
+        "Handle a non-recoverable error."
+        raise exception
+
+    def warning(self, exception):
+        "Handle a warning."
+        print exception
+
+
+# ===== CONTENTHANDLER =====
+
+class ContentHandler:
+    """Interface for receiving logical document content events.
+
+    This is the main callback interface in SAX, and the one most
+    important to applications. The order of events in this interface
+    mirrors the order of the information in the document."""
+
+    def __init__(self):
+        self._locator = None
+
+    def setDocumentLocator(self, locator):
+        """Called by the parser to give the application a locator for
+        locating the origin of document events.
+
+        SAX parsers are strongly encouraged (though not absolutely
+        required) to supply a locator: if it does so, it must supply
+        the locator to the application by invoking this method before
+        invoking any of the other methods in the DocumentHandler
+        interface.
+
+        The locator allows the application to determine the end
+        position of any document-related event, even if the parser is
+        not reporting an error. Typically, the application will use
+        this information for reporting its own errors (such as
+        character content that does not match an application's
+        business rules). The information returned by the locator is
+        probably not sufficient for use with a search engine.
+
+        Note that the locator will return correct information only
+        during the invocation of the events in this interface. The
+        application should not attempt to use it at any other time."""
+        self._locator = locator
+
+    def startDocument(self):
+        """Receive notification of the beginning of a document.
+
+        The SAX parser will invoke this method only once, before any
+        other methods in this interface or in DTDHandler (except for
+        setDocumentLocator)."""
+
+    def endDocument(self):
+        """Receive notification of the end of a document.
+
+        The SAX parser will invoke this method only once, and it will
+        be the last method invoked during the parse. The parser shall
+        not invoke this method until it has either abandoned parsing
+        (because of an unrecoverable error) or reached the end of
+        input."""
+
+    def startPrefixMapping(self, prefix, uri):
+        """Begin the scope of a prefix-URI Namespace mapping.
+
+        The information from this event is not necessary for normal
+        Namespace processing: the SAX XML reader will automatically
+        replace prefixes for element and attribute names when the
+        http://xml.org/sax/features/namespaces feature is true (the
+        default).
+
+        There are cases, however, when applications need to use
+        prefixes in character data or in attribute values, where they
+        cannot safely be expanded automatically; the
+        start/endPrefixMapping event supplies the information to the
+        application to expand prefixes in those contexts itself, if
+        necessary.
+
+        Note that start/endPrefixMapping events are not guaranteed to
+        be properly nested relative to each-other: all
+        startPrefixMapping events will occur before the corresponding
+        startElement event, and all endPrefixMapping events will occur
+        after the corresponding endElement event, but their order is
+        not guaranteed."""
+
+    def endPrefixMapping(self, prefix):
+        """End the scope of a prefix-URI mapping.
+
+        See startPrefixMapping for details. This event will always
+        occur after the corresponding endElement event, but the order
+        of endPrefixMapping events is not otherwise guaranteed."""
+
+    def startElement(self, name, attrs):
+        """Signals the start of an element in non-namespace mode.
+
+        The name parameter contains the raw XML 1.0 name of the
+        element type as a string and the attrs parameter holds an
+        instance of the Attributes class containing the attributes of
+        the element."""
+
+    def endElement(self, name):
+        """Signals the end of an element in non-namespace mode.
+
+        The name parameter contains the name of the element type, just
+        as with the startElement event."""
+
+    def startElementNS(self, name, qname, attrs):
+        """Signals the start of an element in namespace mode.
+
+        The name parameter contains the name of the element type as a
+        (uri, localname) tuple, the qname parameter the raw XML 1.0
+        name used in the source document, and the attrs parameter
+        holds an instance of the Attributes class containing the
+        attributes of the element."""
+
+    def endElementNS(self, name, qname):
+        """Signals the end of an element in namespace mode.
+
+        The name parameter contains the name of the element type, just
+        as with the startElementNS event."""
+
+    def characters(self, content):
+        """Receive notification of character data.
+
+        The Parser will call this method to report each chunk of
+        character data. SAX parsers may return all contiguous
+        character data in a single chunk, or they may split it into
+        several chunks; however, all of the characters in any single
+        event must come from the same external entity so that the
+        Locator provides useful information."""
+
+    def ignorableWhitespace(self, whitespace):
+        """Receive notification of ignorable whitespace in element content.
+
+        Validating Parsers must use this method to report each chunk
+        of ignorable whitespace (see the W3C XML 1.0 recommendation,
+        section 2.10): non-validating parsers may also use this method
+        if they are capable of parsing and using content models.
+
+        SAX parsers may return all contiguous whitespace in a single
+        chunk, or they may split it into several chunks; however, all
+        of the characters in any single event must come from the same
+        external entity, so that the Locator provides useful
+        information.
+
+        The application must not attempt to read from the array
+        outside of the specified range."""
+
+    def processingInstruction(self, target, data):
+        """Receive notification of a processing instruction.
+
+        The Parser will invoke this method once for each processing
+        instruction found: note that processing instructions may occur
+        before or after the main document element.
+
+        A SAX parser should never report an XML declaration (XML 1.0,
+        section 2.8) or a text declaration (XML 1.0, section 4.3.1)
+        using this method."""
+
+    def skippedEntity(self, name):
+        """Receive notification of a skipped entity.
+
+        The Parser will invoke this method once for each entity
+        skipped. Non-validating processors may skip entities if they
+        have not seen the declarations (because, for example, the
+        entity was declared in an external DTD subset). All processors
+        may skip external entities, depending on the values of the
+        http://xml.org/sax/features/external-general-entities and the
+        http://xml.org/sax/features/external-parameter-entities
+        properties."""
+
+
+# ===== DTDHandler =====
+
+class DTDHandler:
+    """Handle DTD events.
+
+    This interface specifies only those DTD events required for basic
+    parsing (unparsed entities and attributes)."""
+
+    def notationDecl(self, name, publicId, systemId):
+        "Handle a notation declaration event."
+
+    def unparsedEntityDecl(self, name, publicId, systemId, ndata):
+        "Handle an unparsed entity declaration event."
+
+
+# ===== ENTITYRESOLVER =====
+
+class EntityResolver:
+    """Basic interface for resolving entities. If you create an object
+    implementing this interface, then register the object with your
+    Parser, the parser will call the method in your object to
+    resolve all external entities. Note that DefaultHandler implements
+    this interface with the default behaviour."""
+
+    def resolveEntity(self, publicId, systemId):
+        """Resolve the system identifier of an entity and return either
+        the system identifier to read from as a string, or an InputSource
+        to read from."""
+        return systemId
+
+
+#============================================================================
+#
+# CORE FEATURES
+#
+#============================================================================
+
+feature_namespaces = "http://xml.org/sax/features/namespaces"
+# true: Perform Namespace processing (default).
+# false: Optionally do not perform Namespace processing
+#        (implies namespace-prefixes).
+# access: (parsing) read-only; (not parsing) read/write
+
+feature_namespace_prefixes = "http://xml.org/sax/features/namespace-prefixes"
+# true: Report the original prefixed names and attributes used for Namespace
+#       declarations.
+# false: Do not report attributes used for Namespace declarations, and
+#        optionally do not report original prefixed names (default).
+# access: (parsing) read-only; (not parsing) read/write
+
+feature_string_interning = "http://xml.org/sax/features/string-interning"
+# true: All element names, prefixes, attribute names, Namespace URIs, and
+#       local names are interned using the built-in intern function.
+# false: Names are not necessarily interned, although they may be (default).
+# access: (parsing) read-only; (not parsing) read/write
+
+feature_validation = "http://xml.org/sax/features/validation"
+# true: Report all validation errors (implies external-general-entities and
+#       external-parameter-entities).
+# false: Do not report validation errors.
+# access: (parsing) read-only; (not parsing) read/write
+
+feature_external_ges = "http://xml.org/sax/features/external-general-entities"
+# true: Include all external general (text) entities.
+# false: Do not include external general entities.
+# access: (parsing) read-only; (not parsing) read/write
+
+feature_external_pes = "http://xml.org/sax/features/external-parameter-entities"
+# true: Include all external parameter entities, including the external
+#       DTD subset.
+# false: Do not include any external parameter entities, even the external
+#        DTD subset.
+# access: (parsing) read-only; (not parsing) read/write
+
+all_features = [feature_namespaces,
+                feature_namespace_prefixes,
+                feature_string_interning,
+                feature_validation,
+                feature_external_ges,
+                feature_external_pes]
+
+
+#============================================================================
+#
+# CORE PROPERTIES
+#
+#============================================================================
+
+property_lexical_handler = "http://xml.org/sax/properties/lexical-handler"
+# data type: xml.sax.sax2lib.LexicalHandler
+# description: An optional extension handler for lexical events like comments.
+# access: read/write
+
+property_declaration_handler = "http://xml.org/sax/properties/declaration-handler"
+# data type: xml.sax.sax2lib.DeclHandler
+# description: An optional extension handler for DTD-related events other
+#              than notations and unparsed entities.
+# access: read/write
+
+property_dom_node = "http://xml.org/sax/properties/dom-node"
+# data type: org.w3c.dom.Node
+# description: When parsing, the current DOM node being visited if this is
+#              a DOM iterator; when not parsing, the root DOM node for
+#              iteration.
+# access: (parsing) read-only; (not parsing) read/write
+
+property_xml_string = "http://xml.org/sax/properties/xml-string"
+# data type: String
+# description: The literal string of characters that was the source for
+#              the current event.
+# access: read-only
+
+all_properties = [property_lexical_handler,
+                  property_dom_node,
+                  property_declaration_handler,
+                  property_xml_string]
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/python-lib/xml/sax/saxutils.py pyexpat-2.2.3-patched/python-lib/xml/sax/saxutils.py
--- pyexpat-2.2.3-orig/python-lib/xml/sax/saxutils.py	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/python-lib/xml/sax/saxutils.py	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,260 @@
+"""\
+A library of useful helper classes to the SAX classes, for the
+convenience of application and driver writers.
+"""
+
+import os, urlparse, urllib, types
+import handler
+import xmlreader
+
+try:
+    _StringTypes = [types.StringType, types.UnicodeType]
+except AttributeError:
+    _StringTypes = [types.StringType]
+
+
+def escape(data, entities={}):
+    """Escape &, <, and > in a string of data.
+
+    You can escape other strings of data by passing a dictionary as
+    the optional entities parameter.  The keys and values must all be
+    strings; each key will be replaced with its corresponding value.
+    """
+    data = data.replace("&", "&amp;")
+    data = data.replace("<", "&lt;")
+    data = data.replace(">", "&gt;")
+    for chars, entity in entities.items():
+        data = data.replace(chars, entity)
+    return data
+
+def quoteattr(data, entities={}):
+    """Escape and quote an attribute value.
+
+    Escape &, <, and > in a string of data, then quote it for use as
+    an attribute value.  The \" character will be escaped as well, if
+    necessary.
+
+    You can escape other strings of data by passing a dictionary as
+    the optional entities parameter.  The keys and values must all be
+    strings; each key will be replaced with its corresponding value.
+    """
+    data = escape(data, entities)
+    if '"' in data:
+        if "'" in data:
+            data = '"%s"' % data.replace('"', "&quot;")
+        else:
+            data = "'%s'" % data
+    else:
+        data = '"%s"' % data
+    return data
+
+
+class XMLGenerator(handler.ContentHandler):
+
+    def __init__(self, out=None, encoding="iso-8859-1"):
+        if out is None:
+            import sys
+            out = sys.stdout
+        handler.ContentHandler.__init__(self)
+        self._out = out
+        self._ns_contexts = [{}] # contains uri -> prefix dicts
+        self._current_context = self._ns_contexts[-1]
+        self._undeclared_ns_maps = []
+        self._encoding = encoding
+
+    # ContentHandler methods
+
+    def startDocument(self):
+        self._out.write('<?xml version="1.0" encoding="%s"?>\n' %
+                        self._encoding)
+
+    def startPrefixMapping(self, prefix, uri):
+        self._ns_contexts.append(self._current_context.copy())
+        self._current_context[uri] = prefix
+        self._undeclared_ns_maps.append((prefix, uri))
+
+    def endPrefixMapping(self, prefix):
+        self._current_context = self._ns_contexts[-1]
+        del self._ns_contexts[-1]
+
+    def startElement(self, name, attrs):
+        self._out.write('<' + name)
+        for (name, value) in attrs.items():
+            self._out.write(' %s=%s' % (name, quoteattr(value)))
+        self._out.write('>')
+
+    def endElement(self, name):
+        self._out.write('</%s>' % name)
+
+    def startElementNS(self, name, qname, attrs):
+        if name[0] is None:
+            # if the name was not namespace-scoped, use the unqualified part
+            name = name[1]
+        else:
+            # else try to restore the original prefix from the namespace
+            name = self._current_context[name[0]] + ":" + name[1]
+        self._out.write('<' + name)
+
+        for pair in self._undeclared_ns_maps:
+            self._out.write(' xmlns:%s="%s"' % pair)
+        self._undeclared_ns_maps = []
+
+        for (name, value) in attrs.items():
+            name = self._current_context[name[0]] + ":" + name[1]
+            self._out.write(' %s=%s' % (name, quoteattr(value)))
+        self._out.write('>')
+
+    def endElementNS(self, name, qname):
+        if name[0] is None:
+            name = name[1]
+        else:
+            name = self._current_context[name[0]] + ":" + name[1]
+        self._out.write('</%s>' % name)
+
+    def characters(self, content):
+        self._out.write(escape(content))
+
+    def ignorableWhitespace(self, content):
+        self._out.write(content)
+
+    def processingInstruction(self, target, data):
+        self._out.write('<?%s %s?>' % (target, data))
+
+
+class XMLFilterBase(xmlreader.XMLReader):
+    """This class is designed to sit between an XMLReader and the
+    client application's event handlers.  By default, it does nothing
+    but pass requests up to the reader and events on to the handlers
+    unmodified, but subclasses can override specific methods to modify
+    the event stream or the configuration requests as they pass
+    through."""
+
+    def __init__(self, parent = None):
+        xmlreader.XMLReader.__init__(self)
+        self._parent = parent
+
+    # ErrorHandler methods
+
+    def error(self, exception):
+        self._err_handler.error(exception)
+
+    def fatalError(self, exception):
+        self._err_handler.fatalError(exception)
+
+    def warning(self, exception):
+        self._err_handler.warning(exception)
+
+    # ContentHandler methods
+
+    def setDocumentLocator(self, locator):
+        self._cont_handler.setDocumentLocator(locator)
+
+    def startDocument(self):
+        self._cont_handler.startDocument()
+
+    def endDocument(self):
+        self._cont_handler.endDocument()
+
+    def startPrefixMapping(self, prefix, uri):
+        self._cont_handler.startPrefixMapping(prefix, uri)
+
+    def endPrefixMapping(self, prefix):
+        self._cont_handler.endPrefixMapping(prefix)
+
+    def startElement(self, name, attrs):
+        self._cont_handler.startElement(name, attrs)
+
+    def endElement(self, name):
+        self._cont_handler.endElement(name)
+
+    def startElementNS(self, name, qname, attrs):
+        self._cont_handler.startElement(name, attrs)
+
+    def endElementNS(self, name, qname):
+        self._cont_handler.endElementNS(name, qname)
+
+    def characters(self, content):
+        self._cont_handler.characters(content)
+
+    def ignorableWhitespace(self, chars):
+        self._cont_handler.ignorableWhitespace(chars)
+
+    def processingInstruction(self, target, data):
+        self._cont_handler.processingInstruction(target, data)
+
+    def skippedEntity(self, name):
+        self._cont_handler.skippedEntity(name)
+
+    # DTDHandler methods
+
+    def notationDecl(self, name, publicId, systemId):
+        self._dtd_handler.notationDecl(name, publicId, systemId)
+
+    def unparsedEntityDecl(self, name, publicId, systemId, ndata):
+        self._dtd_handler.unparsedEntityDecl(name, publicId, systemId, ndata)
+
+    # EntityResolver methods
+
+    def resolveEntity(self, publicId, systemId):
+        self._ent_handler.resolveEntity(publicId, systemId)
+
+    # XMLReader methods
+
+    def parse(self, source):
+        self._parent.setContentHandler(self)
+        self._parent.setErrorHandler(self)
+        self._parent.setEntityResolver(self)
+        self._parent.setDTDHandler(self)
+        self._parent.parse(source)
+
+    def setLocale(self, locale):
+        self._parent.setLocale(locale)
+
+    def getFeature(self, name):
+        return self._parent.getFeature(name)
+
+    def setFeature(self, name, state):
+        self._parent.setFeature(name, state)
+
+    def getProperty(self, name):
+        return self._parent.getProperty(name)
+
+    def setProperty(self, name, value):
+        self._parent.setProperty(name, value)
+
+    # XMLFilter methods
+
+    def getParent(self):
+        return self._parent
+
+    def setParent(self, parent):
+        self._parent = parent
+
+# --- Utility functions
+
+def prepare_input_source(source, base = ""):
+    """This function takes an InputSource and an optional base URL and
+    returns a fully resolved InputSource object ready for reading."""
+
+    if type(source) in _StringTypes:
+        source = xmlreader.InputSource(source)
+    elif hasattr(source, "read"):
+        f = source
+        source = xmlreader.InputSource()
+        source.setByteStream(f)
+        if hasattr(f, "name"):
+            source.setSystemId(f.name)
+
+    if source.getByteStream() is None:
+        sysid = source.getSystemId()
+        if os.path.isfile(sysid):
+            basehead = os.path.split(os.path.normpath(base))[0]
+            source.setSystemId(os.path.join(basehead, sysid))
+            f = open(sysid, "rb")
+        else:
+            source.setSystemId(urlparse.urljoin(base, sysid))
+            f = urllib.urlopen(source.getSystemId())
+
+        source.setByteStream(f)
+
+    return source
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/python-lib/xml/sax/xmlreader.py pyexpat-2.2.3-patched/python-lib/xml/sax/xmlreader.py
--- pyexpat-2.2.3-orig/python-lib/xml/sax/xmlreader.py	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/python-lib/xml/sax/xmlreader.py	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,378 @@
+"""An XML Reader is the SAX 2 name for an XML parser. XML Parsers
+should be based on this code. """
+
+import handler
+
+from _exceptions import SAXNotSupportedException, SAXNotRecognizedException
+
+
+# ===== XMLREADER =====
+
+class XMLReader:
+    """Interface for reading an XML document using callbacks.
+
+    XMLReader is the interface that an XML parser's SAX2 driver must
+    implement. This interface allows an application to set and query
+    features and properties in the parser, to register event handlers
+    for document processing, and to initiate a document parse.
+
+    All SAX interfaces are assumed to be synchronous: the parse
+    methods must not return until parsing is complete, and readers
+    must wait for an event-handler callback to return before reporting
+    the next event."""
+
+    def __init__(self):
+        self._cont_handler = handler.ContentHandler()
+        self._dtd_handler = handler.DTDHandler()
+        self._ent_handler = handler.EntityResolver()
+        self._err_handler = handler.ErrorHandler()
+
+    def parse(self, source):
+        "Parse an XML document from a system identifier or an InputSource."
+        raise NotImplementedError("This method must be implemented!")
+
+    def getContentHandler(self):
+        "Returns the current ContentHandler."
+        return self._cont_handler
+
+    def setContentHandler(self, handler):
+        "Registers a new object to receive document content events."
+        self._cont_handler = handler
+
+    def getDTDHandler(self):
+        "Returns the current DTD handler."
+        return self._dtd_handler
+
+    def setDTDHandler(self, handler):
+        "Register an object to receive basic DTD-related events."
+        self._dtd_handler = handler
+
+    def getEntityResolver(self):
+        "Returns the current EntityResolver."
+        return self._ent_handler
+
+    def setEntityResolver(self, resolver):
+        "Register an object to resolve external entities."
+        self._ent_handler = resolver
+
+    def getErrorHandler(self):
+        "Returns the current ErrorHandler."
+        return self._err_handler
+
+    def setErrorHandler(self, handler):
+        "Register an object to receive error-message events."
+        self._err_handler = handler
+
+    def setLocale(self, locale):
+        """Allow an application to set the locale for errors and warnings.
+
+        SAX parsers are not required to provide localization for errors
+        and warnings; if they cannot support the requested locale,
+        however, they must throw a SAX exception. Applications may
+        request a locale change in the middle of a parse."""
+        raise SAXNotSupportedException("Locale support not implemented")
+
+    def getFeature(self, name):
+        "Looks up and returns the state of a SAX2 feature."
+        raise SAXNotRecognizedException("Feature '%s' not recognized" % name)
+
+    def setFeature(self, name, state):
+        "Sets the state of a SAX2 feature."
+        raise SAXNotRecognizedException("Feature '%s' not recognized" % name)
+
+    def getProperty(self, name):
+        "Looks up and returns the value of a SAX2 property."
+        raise SAXNotRecognizedException("Property '%s' not recognized" % name)
+
+    def setProperty(self, name, value):
+        "Sets the value of a SAX2 property."
+        raise SAXNotRecognizedException("Property '%s' not recognized" % name)
+
+class IncrementalParser(XMLReader):
+    """This interface adds three extra methods to the XMLReader
+    interface that allow XML parsers to support incremental
+    parsing. Support for this interface is optional, since not all
+    underlying XML parsers support this functionality.
+
+    When the parser is instantiated it is ready to begin accepting
+    data from the feed method immediately. After parsing has been
+    finished with a call to close the reset method must be called to
+    make the parser ready to accept new data, either from feed or
+    using the parse method.
+
+    Note that these methods must _not_ be called during parsing, that
+    is, after parse has been called and before it returns.
+
+    By default, the class also implements the parse method of the XMLReader
+    interface using the feed, close and reset methods of the
+    IncrementalParser interface as a convenience to SAX 2.0 driver
+    writers."""
+
+    def __init__(self, bufsize=2**16):
+        self._bufsize = bufsize
+        XMLReader.__init__(self)
+
+    def parse(self, source):
+        import saxutils
+        source = saxutils.prepare_input_source(source)
+
+        self.prepareParser(source)
+        file = source.getByteStream()
+        buffer = file.read(self._bufsize)
+        while buffer != "":
+            self.feed(buffer)
+            buffer = file.read(self._bufsize)
+        self.close()
+
+    def feed(self, data):
+        """This method gives the raw XML data in the data parameter to
+        the parser and makes it parse the data, emitting the
+        corresponding events. It is allowed for XML constructs to be
+        split across several calls to feed.
+
+        feed may raise SAXException."""
+        raise NotImplementedError("This method must be implemented!")
+
+    def prepareParser(self, source):
+        """This method is called by the parse implementation to allow
+        the SAX 2.0 driver to prepare itself for parsing."""
+        raise NotImplementedError("prepareParser must be overridden!")
+
+    def close(self):
+        """This method is called when the entire XML document has been
+        passed to the parser through the feed method, to notify the
+        parser that there are no more data. This allows the parser to
+        do the final checks on the document and empty the internal
+        data buffer.
+
+        The parser will not be ready to parse another document until
+        the reset method has been called.
+
+        close may raise SAXException."""
+        raise NotImplementedError("This method must be implemented!")
+
+    def reset(self):
+        """This method is called after close has been called to reset
+        the parser so that it is ready to parse new documents. The
+        results of calling parse or feed after close without calling
+        reset are undefined."""
+        raise NotImplementedError("This method must be implemented!")
+
+# ===== LOCATOR =====
+
+class Locator:
+    """Interface for associating a SAX event with a document
+    location. A locator object will return valid results only during
+    calls to DocumentHandler methods; at any other time, the
+    results are unpredictable."""
+
+    def getColumnNumber(self):
+        "Return the column number where the current event ends."
+        return -1
+
+    def getLineNumber(self):
+        "Return the line number where the current event ends."
+        return -1
+
+    def getPublicId(self):
+        "Return the public identifier for the current event."
+        return None
+
+    def getSystemId(self):
+        "Return the system identifier for the current event."
+        return None
+
+# ===== INPUTSOURCE =====
+
+class InputSource:
+    """Encapsulation of the information needed by the XMLReader to
+    read entities.
+
+    This class may include information about the public identifier,
+    system identifier, byte stream (possibly with character encoding
+    information) and/or the character stream of an entity.
+
+    Applications will create objects of this class for use in the
+    XMLReader.parse method and for returning from
+    EntityResolver.resolveEntity.
+
+    An InputSource belongs to the application, the XMLReader is not
+    allowed to modify InputSource objects passed to it from the
+    application, although it may make copies and modify those."""
+
+    def __init__(self, system_id = None):
+        self.__system_id = system_id
+        self.__public_id = None
+        self.__encoding  = None
+        self.__bytefile  = None
+        self.__charfile  = None
+
+    def setPublicId(self, public_id):
+        "Sets the public identifier of this InputSource."
+        self.__public_id = public_id
+
+    def getPublicId(self):
+        "Returns the public identifier of this InputSource."
+        return self.__public_id
+
+    def setSystemId(self, system_id):
+        "Sets the system identifier of this InputSource."
+        self.__system_id = system_id
+
+    def getSystemId(self):
+        "Returns the system identifier of this InputSource."
+        return self.__system_id
+
+    def setEncoding(self, encoding):
+        """Sets the character encoding of this InputSource.
+
+        The encoding must be a string acceptable for an XML encoding
+        declaration (see section 4.3.3 of the XML recommendation).
+
+        The encoding attribute of the InputSource is ignored if the
+        InputSource also contains a character stream."""
+        self.__encoding = encoding
+
+    def getEncoding(self):
+        "Get the character encoding of this InputSource."
+        return self.__encoding
+
+    def setByteStream(self, bytefile):
+        """Set the byte stream (a Python file-like object which does
+        not perform byte-to-character conversion) for this input
+        source.
+
+        The SAX parser will ignore this if there is also a character
+        stream specified, but it will use a byte stream in preference
+        to opening a URI connection itself.
+
+        If the application knows the character encoding of the byte
+        stream, it should set it with the setEncoding method."""
+        self.__bytefile = bytefile
+
+    def getByteStream(self):
+        """Get the byte stream for this input source.
+
+        The getEncoding method will return the character encoding for
+        this byte stream, or None if unknown."""
+        return self.__bytefile
+
+    def setCharacterStream(self, charfile):
+        """Set the character stream for this input source. (The stream
+        must be a Python 2.0 Unicode-wrapped file-like that performs
+        conversion to Unicode strings.)
+
+        If there is a character stream specified, the SAX parser will
+        ignore any byte stream and will not attempt to open a URI
+        connection to the system identifier."""
+        self.__charfile = charfile
+
+    def getCharacterStream(self):
+        "Get the character stream for this input source."
+        return self.__charfile
+
+# ===== ATTRIBUTESIMPL =====
+
+class AttributesImpl:
+
+    def __init__(self, attrs):
+        """Non-NS-aware implementation.
+
+        attrs should be of the form {name : value}."""
+        self._attrs = attrs
+
+    def getLength(self):
+        return len(self._attrs)
+
+    def getType(self, name):
+        return "CDATA"
+
+    def getValue(self, name):
+        return self._attrs[name]
+
+    def getValueByQName(self, name):
+        return self._attrs[name]
+
+    def getNameByQName(self, name):
+        if not self._attrs.has_key(name):
+            raise KeyError, name
+        return name
+
+    def getQNameByName(self, name):
+        if not self._attrs.has_key(name):
+            raise KeyError, name
+        return name
+
+    def getNames(self):
+        return self._attrs.keys()
+
+    def getQNames(self):
+        return self._attrs.keys()
+
+    def __len__(self):
+        return len(self._attrs)
+
+    def __getitem__(self, name):
+        return self._attrs[name]
+
+    def keys(self):
+        return self._attrs.keys()
+
+    def has_key(self, name):
+        return self._attrs.has_key(name)
+
+    def get(self, name, alternative=None):
+        return self._attrs.get(name, alternative)
+
+    def copy(self):
+        return self.__class__(self._attrs)
+
+    def items(self):
+        return self._attrs.items()
+
+    def values(self):
+        return self._attrs.values()
+
+# ===== ATTRIBUTESNSIMPL =====
+
+class AttributesNSImpl(AttributesImpl):
+
+    def __init__(self, attrs, qnames):
+        """NS-aware implementation.
+
+        attrs should be of the form {(ns_uri, lname): value, ...}.
+        qnames of the form {(ns_uri, lname): qname, ...}."""
+        self._attrs = attrs
+        self._qnames = qnames
+
+    def getValueByQName(self, name):
+        for (nsname, qname) in self._qnames.items():
+            if qname == name:
+                return self._attrs[nsname]
+
+        raise KeyError, name
+
+    def getNameByQName(self, name):
+        for (nsname, qname) in self._qnames.items():
+            if qname == name:
+                return nsname
+
+        raise KeyError, name
+
+    def getQNameByName(self, name):
+        return self._qnames[name]
+
+    def getQNames(self):
+        return self._qnames.values()
+
+    def copy(self):
+        return self.__class__(self._attrs, self._qnames)
+
+
+def _test():
+    XMLReader()
+    IncrementalParser()
+    Locator()
+
+if __name__ == "__main__":
+    _test()
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/src/dllentry.cpp pyexpat-2.2.3-patched/src/dllentry.cpp
--- pyexpat-2.2.3-orig/src/dllentry.cpp	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/src/dllentry.cpp	2007-12-21 11:25:26.000000000 +0200
@@ -0,0 +1,12 @@
+// -*- symbian-c++ -*-
+
+#include <e32std.h>
+
+#ifndef EKA2
+/** The DLL entry point.
+ */
+GLDEF_C TInt E32Dll(TDllReason)
+	{
+	return KErrNone;
+	}
+#endif
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/src/logging.cpp pyexpat-2.2.3-patched/src/logging.cpp
--- pyexpat-2.2.3-orig/src/logging.cpp	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/src/logging.cpp	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,25 @@
+// -*- symbian-c++ -*-
+
+#include <flogger.h> // flogger.lib required, Symbian 7.0-up
+
+static void Log(const TDesC8& aText)
+	{
+	RFileLogger log;
+	TInt error = log.Connect();
+	if (error)
+		{
+		return;
+		}
+	_LIT(KLogFileDir, "pyexpat");
+	_LIT(KLogFileName, "pyexpat.txt");
+	log.CreateLog(KLogFileDir, KLogFileName, 
+				  EFileLoggingModeOverwrite);
+	log.Write(aText);
+	log.Close();
+	}
+
+extern "C" void Log(const char* aText)
+	{
+	TPtrC8 ptr(reinterpret_cast<const TUint8*>(aText));
+	Log(ptr);
+	}
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/src/pyexpat.c pyexpat-2.2.3-patched/src/pyexpat.c
--- pyexpat-2.2.3-orig/src/pyexpat.c	2006-11-06 14:09:59.000000000 +0200
+++ pyexpat-2.2.3-patched/src/pyexpat.c	1970-01-01 02:00:00.000000000 +0200
@@ -1,1942 +0,0 @@
-#include "Python.h"
-#if PY_VERSION_HEX < 0x020000B1
-#include <assert.h>
-#endif
-#include <ctype.h>
-
-#include "compile.h"
-#include "frameobject.h"
-#ifdef HAVE_EXPAT_H
-#include "expat.h"
-#ifdef XML_MAJOR_VERSION
-#define EXPAT_VERSION (0x10000 * XML_MAJOR_VERSION \
-                       + 0x100 * XML_MINOR_VERSION \
-                       + XML_MICRO_VERSION)
-#else
-/* Assume the oldest Expat that used expat.h and did not have version info */
-#define EXPAT_VERSION 0x015f00
-#endif
-#else /* !defined(HAVE_EXPAT_H) */
-#include "xmlparse.h"
-/* Assume Expat 1.1 unless told otherwise */
-#ifndef EXPAT_VERSION
-#define EXPAT_VERSION 0x010100
-#endif
-#endif /* !defined(HAVE_EXPAT_H) */
-
-#ifndef PyGC_HEAD_SIZE
-#define PyGC_HEAD_SIZE 0
-#define PyObject_GC_Init(x)
-#define PyObject_GC_Fini(m)
-#define Py_TPFLAGS_GC 0
-#endif
-
-#if (PY_MAJOR_VERSION == 1 && PY_MINOR_VERSION > 5) || (PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION < 2)
-/* In Python 1.6, 2.0 and  2.1, disabling Unicode was not possible. */
-#define Py_USING_UNICODE
-#endif
-
-enum HandlerTypes {
-    StartElement,
-    EndElement,
-    ProcessingInstruction,
-    CharacterData,
-    UnparsedEntityDecl,
-    NotationDecl,
-    StartNamespaceDecl,
-    EndNamespaceDecl,
-    Comment,
-    StartCdataSection,
-    EndCdataSection,
-    Default,
-    DefaultHandlerExpand,
-    NotStandalone,
-    ExternalEntityRef,
-#if EXPAT_VERSION >= 0x010200
-    StartDoctypeDecl,
-    EndDoctypeDecl,
-#endif
-#if EXPAT_VERSION == 0x010200
-    ExternalParsedEntityDecl,
-    InternalParsedEntityDecl,
-#endif
-#if EXPAT_VERSION >= 0x015f00
-    EntityDecl,
-    XmlDecl,
-    ElementDecl,
-    AttlistDecl,
-#endif
-    _DummyDecl
-};
-
-static PyObject *ErrorObject;
-
-/* ----------------------------------------------------- */
-
-/* Declarations for objects of type xmlparser */
-
-typedef struct {
-    PyObject_HEAD
-
-    XML_Parser itself;
-    int returns_unicode;        /* True if Unicode strings are returned;
-                                   if false, UTF-8 strings are returned */
-    int ordered_attributes;     /* Return attributes as a list. */
-    int specified_attributes;   /* Report only specified attributes. */
-    int in_callback;            /* Is a callback active? */
-    PyObject **handlers;
-} xmlparseobject;
-
-staticforward PyTypeObject Xmlparsetype;
-
-typedef void (*xmlhandlersetter)(XML_Parser self, void *meth);
-typedef void* xmlhandler;
-
-struct HandlerInfo {
-    const char *name;
-    xmlhandlersetter setter;
-    xmlhandler handler;
-    PyCodeObject *tb_code;
-};
-
-staticforward struct HandlerInfo handler_info[64];
-
-/* Set an integer attribute on the error object; return true on success,
- * false on an exception.
- */
-static int
-set_error_attr(PyObject *err, char *name, int value)
-{
-    PyObject *v = PyInt_FromLong(value);
-
-    if (v != NULL && PyObject_SetAttrString(err, name, v) == -1) {
-        Py_DECREF(v);
-        return 0;
-    }
-    return 1;
-}
-
-/* Build and set an Expat exception, including positioning
- * information.  Always returns NULL.
- */
-static PyObject *
-set_error(xmlparseobject *self)
-{
-    PyObject *err;
-    char buffer[256];
-    XML_Parser parser = self->itself;
-    int lineno = XML_GetErrorLineNumber(parser);
-    int column = XML_GetErrorColumnNumber(parser);
-    enum XML_Error code = XML_GetErrorCode(parser);
-
-    PyOS_snprintf(buffer, sizeof(buffer), "%.200s: line %i, column %i",
-            XML_ErrorString(code), lineno, column);
-    err = PyObject_CallFunction(ErrorObject, "s", buffer);
-    if (  err != NULL
-          && set_error_attr(err, "code", code)
-          && set_error_attr(err, "offset", column)
-          && set_error_attr(err, "lineno", lineno)) {
-        PyErr_SetObject(ErrorObject, err);
-    }
-    return NULL;
-}
-
-
-#if EXPAT_VERSION == 0x010200
-/* Convert an array of attributes and their values into a Python dict */
-
-static PyObject *
-conv_atts_using_string(XML_Char **atts)
-{
-    PyObject *attrs_obj = NULL;
-    XML_Char **attrs_p, **attrs_k = NULL;
-    int attrs_len;
-    PyObject *rv;
-
-    if ((attrs_obj = PyDict_New()) == NULL) 
-        goto finally;
-    for (attrs_len = 0, attrs_p = atts; 
-         *attrs_p;
-         attrs_p++, attrs_len++) {
-        if (attrs_len % 2) {
-            rv = PyString_FromString(*attrs_p);  
-            if (!rv) {
-                Py_DECREF(attrs_obj);
-                attrs_obj = NULL;
-                goto finally;
-            }
-            if (PyDict_SetItemString(attrs_obj,
-                                     (char*)*attrs_k, rv) < 0) {
-                Py_DECREF(attrs_obj);
-                attrs_obj = NULL;
-                goto finally;
-            }
-            Py_DECREF(rv);
-        }
-        else 
-            attrs_k = attrs_p;
-    }
- finally:
-    return attrs_obj;
-}
-#endif
-
-#ifdef Py_USING_UNICODE
-#if EXPAT_VERSION == 0x010200
-static PyObject *
-conv_atts_using_unicode(XML_Char **atts)
-{
-    PyObject *attrs_obj;
-    XML_Char **attrs_p, **attrs_k = NULL;
-    int attrs_len;
-
-    if ((attrs_obj = PyDict_New()) == NULL) 
-        goto finally;
-    for (attrs_len = 0, attrs_p = atts; 
-         *attrs_p;
-         attrs_p++, attrs_len++) {
-        if (attrs_len % 2) {
-            PyObject *attr_str, *value_str;
-            const char *p = (const char *) (*attrs_k);
-            attr_str = PyUnicode_DecodeUTF8(p, strlen(p), "strict"); 
-            if (!attr_str) {
-                Py_DECREF(attrs_obj);
-                attrs_obj = NULL;
-                goto finally;
-            }
-            p = (const char *) *attrs_p;
-            value_str = PyUnicode_DecodeUTF8(p, strlen(p), "strict");
-            if (!value_str) {
-                Py_DECREF(attrs_obj);
-                Py_DECREF(attr_str);
-                attrs_obj = NULL;
-                goto finally;
-            }
-            if (PyDict_SetItem(attrs_obj, attr_str, value_str) < 0) {
-                Py_DECREF(attrs_obj);
-                Py_DECREF(attr_str);
-                Py_DECREF(value_str);
-                attrs_obj = NULL;
-                goto finally;
-            }
-            Py_DECREF(attr_str);
-            Py_DECREF(value_str);
-        }
-        else
-            attrs_k = attrs_p;
-    }
- finally:
-    return attrs_obj;
-}
-#endif
-
-/* Convert a string of XML_Chars into a Unicode string.
-   Returns None if str is a null pointer. */
-
-static PyObject *
-conv_string_to_unicode(XML_Char *str)
-{
-    /* XXX currently this code assumes that XML_Char is 8-bit, 
-       and hence in UTF-8.  */
-    /* UTF-8 from Expat, Unicode desired */
-    if (str == NULL) {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-    return PyUnicode_DecodeUTF8((const char *)str, 
-                                strlen((const char *)str), 
-                                "strict");
-}
-
-static PyObject *
-conv_string_len_to_unicode(const XML_Char *str, int len)
-{
-    /* XXX currently this code assumes that XML_Char is 8-bit, 
-       and hence in UTF-8.  */
-    /* UTF-8 from Expat, Unicode desired */
-    if (str == NULL) {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-    return PyUnicode_DecodeUTF8((const char *)str, len, "strict");
-}
-#endif
-
-/* Convert a string of XML_Chars into an 8-bit Python string.
-   Returns None if str is a null pointer. */
-
-static PyObject *
-conv_string_to_utf8(XML_Char *str)
-{
-    /* XXX currently this code assumes that XML_Char is 8-bit, 
-       and hence in UTF-8.  */
-    /* UTF-8 from Expat, UTF-8 desired */
-    if (str == NULL) {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-    return PyString_FromString((const char *)str);
-}
-
-static PyObject *
-conv_string_len_to_utf8(const XML_Char *str,  int len) 
-{
-    /* XXX currently this code assumes that XML_Char is 8-bit, 
-       and hence in UTF-8.  */
-    /* UTF-8 from Expat, UTF-8 desired */
-    if (str == NULL) {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-    return PyString_FromStringAndSize((const char *)str, len);
-}
-
-/* Callback routines */
-
-static void clear_handlers(xmlparseobject *self, int initial);
-
-static void
-flag_error(xmlparseobject *self)
-{
-    clear_handlers(self, 0);
-}
-
-static PyCodeObject*
-getcode(enum HandlerTypes slot, char* func_name, int lineno)
-{
-    PyObject *code = NULL;
-    PyObject *name = NULL;
-    PyObject *nulltuple = NULL;
-    PyObject *filename = NULL;
-
-    if (handler_info[slot].tb_code == NULL) {
-        code = PyString_FromString("");
-        if (code == NULL)
-            goto failed;
-        name = PyString_FromString(func_name);
-        if (name == NULL)
-            goto failed;
-        nulltuple = PyTuple_New(0);
-        if (nulltuple == NULL)
-            goto failed;
-        filename = PyString_FromString(__FILE__);
-        handler_info[slot].tb_code =
-            PyCode_New(0,		/* argcount */
-                       0,		/* nlocals */
-                       0,		/* stacksize */
-                       0,		/* flags */
-                       code,		/* code */
-                       nulltuple,	/* consts */
-                       nulltuple,	/* names */
-                       nulltuple,	/* varnames */
-#if PYTHON_API_VERSION >= 1010
-                       nulltuple,	/* freevars */
-                       nulltuple,	/* cellvars */
-#endif
-                       filename,	/* filename */
-                       name,		/* name */
-                       lineno,		/* firstlineno */
-                       code		/* lnotab */
-                       );
-        if (handler_info[slot].tb_code == NULL)
-            goto failed;
-        Py_DECREF(code);
-        Py_DECREF(nulltuple);
-        Py_DECREF(filename);
-        Py_DECREF(name);
-    }
-    return handler_info[slot].tb_code;
- failed:
-    Py_XDECREF(code);
-    Py_XDECREF(name);
-    return NULL;
-}
-
-static int
-trace_frame(PyThreadState *tstate, PyFrameObject *f, int code, PyObject *val)
-{
-    int result = 0;
-    if (!tstate->use_tracing || tstate->tracing)
-	return 0;
-    if (tstate->c_profilefunc != NULL) {
-	tstate->tracing++;
-	result = tstate->c_profilefunc(tstate->c_profileobj,
-				       f, code , val);
-	tstate->use_tracing = ((tstate->c_tracefunc != NULL)
-			       || (tstate->c_profilefunc != NULL));
-	tstate->tracing--;
-	if (result)
-	    return result;
-    }
-    if (tstate->c_tracefunc != NULL) {
-	tstate->tracing++;
-	result = tstate->c_tracefunc(tstate->c_traceobj,
-				     f, code , val);
-	tstate->use_tracing = ((tstate->c_tracefunc != NULL)
-			       || (tstate->c_profilefunc != NULL));
-	tstate->tracing--;
-    }	
-    return result;
-}
-
-static PyObject*
-call_with_frame(PyCodeObject *c, PyObject* func, PyObject* args)
-{
-    PyThreadState *tstate = PyThreadState_GET();
-    PyFrameObject *f;
-    PyObject *res;
-
-    if (c == NULL)
-        return NULL;
-    
-    f = PyFrame_New(
-                    tstate,			/*back*/
-                    c,				/*code*/
-                    PyEval_GetGlobals(),	/*globals*/
-                    NULL			/*locals*/
-                    );
-    if (f == NULL)
-        return NULL;
-    tstate->frame = f;
-    if (trace_frame(tstate, f, PyTrace_CALL, Py_None)) {
-	Py_DECREF(f);
-	return NULL;
-    }
-    res = PyEval_CallObject(func, args);
-    if (res == NULL && tstate->curexc_traceback == NULL)
-        PyTraceBack_Here(f);
-    else {
-	if (trace_frame(tstate, f, PyTrace_RETURN, res)) {
-	    Py_XDECREF(res);
-	    res = NULL;
-	}
-    }
-    tstate->frame = f->f_back;
-    Py_DECREF(f);
-    return res;
-}
-
-#ifndef Py_USING_UNICODE
-#define STRING_CONV_FUNC conv_string_to_utf8
-#else
-/* Python 1.6 and later versions */
-#define STRING_CONV_FUNC (self->returns_unicode \
-                          ? conv_string_to_unicode : conv_string_to_utf8)
-#endif
-
-static void
-my_StartElementHandler(void *userData,
-                       const XML_Char *name, const XML_Char **atts)
-{
-    xmlparseobject *self = (xmlparseobject *)userData;
-
-    if (self->handlers[StartElement]
-        && self->handlers[StartElement] != Py_None) {
-        PyObject *container, *rv, *args;
-        int i, max;
-
-        /* Set max to the number of slots filled in atts[]; max/2 is
-         * the number of attributes we need to process.
-         */
-        if (self->specified_attributes) {
-            max = XML_GetSpecifiedAttributeCount(self->itself);
-        }
-        else {
-            max = 0;
-            while (atts[max] != NULL)
-                max += 2;
-        }
-        /* Build the container. */
-        if (self->ordered_attributes)
-            container = PyList_New(max);
-        else
-            container = PyDict_New();
-        if (container == NULL) {
-            flag_error(self);
-            return;
-        }
-        for (i = 0; i < max; i += 2) {
-            PyObject *n = STRING_CONV_FUNC((XML_Char *) atts[i]);
-            PyObject *v;
-            if (n == NULL) {
-                flag_error(self);
-                Py_DECREF(container);
-                return;
-            }
-            v = STRING_CONV_FUNC((XML_Char *) atts[i+1]);
-            if (v == NULL) {
-                flag_error(self);
-                Py_DECREF(container);
-                Py_DECREF(n);
-                return;
-            }
-            if (self->ordered_attributes) {
-                PyList_SET_ITEM(container, i, n);
-                PyList_SET_ITEM(container, i+1, v);
-            }
-            else if (PyDict_SetItem(container, n, v)) {
-                flag_error(self);
-                Py_DECREF(n);
-                Py_DECREF(v);
-                return;
-            }
-            else {
-                Py_DECREF(n);
-                Py_DECREF(v);
-            }
-        }
-        args = Py_BuildValue("(O&N)", STRING_CONV_FUNC,name, container);
-        if (args == NULL) {
-            Py_DECREF(container);
-            return;
-        }
-        /* Container is now a borrowed reference; ignore it. */
-        self->in_callback = 1;
-        rv = call_with_frame(getcode(StartElement, "StartElement", __LINE__),
-                             self->handlers[StartElement], args);
-        self->in_callback = 0;
-        Py_DECREF(args);
-        if (rv == NULL) {
-            flag_error(self);
-            return;
-        }
-        Py_DECREF(rv);
-    }
-}
-
-#define RC_HANDLER(RC, NAME, PARAMS, INIT, PARAM_FORMAT, CONVERSION, \
-                RETURN, GETUSERDATA) \
-static RC \
-my_##NAME##Handler PARAMS {\
-    xmlparseobject *self = GETUSERDATA ; \
-    PyObject *args = NULL; \
-    PyObject *rv = NULL; \
-    INIT \
-\
-    if (self->handlers[NAME] \
-        && self->handlers[NAME] != Py_None) { \
-        args = Py_BuildValue PARAM_FORMAT ;\
-        if (!args) { flag_error(self); return RETURN;} \
-        self->in_callback = 1; \
-        rv = call_with_frame(getcode(NAME,#NAME,__LINE__), \
-                             self->handlers[NAME], args); \
-        self->in_callback = 0; \
-        Py_DECREF(args); \
-        if (rv == NULL) { \
-            flag_error(self); \
-            return RETURN; \
-        } \
-        CONVERSION \
-        Py_DECREF(rv); \
-    } \
-    return RETURN; \
-}
-
-#define VOID_HANDLER(NAME, PARAMS, PARAM_FORMAT) \
-	RC_HANDLER(void, NAME, PARAMS, ;, PARAM_FORMAT, ;, ;,\
-	(xmlparseobject *)userData)
-
-#define INT_HANDLER(NAME, PARAMS, PARAM_FORMAT)\
-	RC_HANDLER(int, NAME, PARAMS, int rc=0;, PARAM_FORMAT, \
-			rc = PyInt_AsLong(rv);, rc, \
-	(xmlparseobject *)userData)
-
-VOID_HANDLER(EndElement, 
-             (void *userData, const XML_Char *name), 
-             ("(O&)", STRING_CONV_FUNC, name))
-
-VOID_HANDLER(ProcessingInstruction,
-             (void *userData, 
-              const XML_Char *target, 
-              const XML_Char *data),
-             ("(O&O&)",STRING_CONV_FUNC,target, STRING_CONV_FUNC,data))
-
-#ifndef Py_USING_UNICODE
-VOID_HANDLER(CharacterData, 
-             (void *userData, const XML_Char *data, int len), 
-             ("(N)", conv_string_len_to_utf8(data,len)))
-#else
-VOID_HANDLER(CharacterData, 
-             (void *userData, const XML_Char *data, int len), 
-             ("(N)", (self->returns_unicode 
-                      ? conv_string_len_to_unicode(data,len) 
-                      : conv_string_len_to_utf8(data,len))))
-#endif
-
-VOID_HANDLER(UnparsedEntityDecl,
-             (void *userData, 
-              const XML_Char *entityName,
-              const XML_Char *base,
-              const XML_Char *systemId,
-              const XML_Char *publicId,
-              const XML_Char *notationName),
-             ("(O&O&O&O&O&)", 
-              STRING_CONV_FUNC,entityName, STRING_CONV_FUNC,base, 
-              STRING_CONV_FUNC,systemId, STRING_CONV_FUNC,publicId, 
-              STRING_CONV_FUNC,notationName))
-
-#if EXPAT_VERSION >= 0x015f00
-#ifndef Py_USING_UNICODE
-VOID_HANDLER(EntityDecl,
-             (void *userData,
-              const XML_Char *entityName,
-              int is_parameter_entity,
-              const XML_Char *value,
-              int value_length,
-              const XML_Char *base,
-              const XML_Char *systemId,
-              const XML_Char *publicId,
-              const XML_Char *notationName),
-             ("O&iNO&O&O&O&",
-              STRING_CONV_FUNC,entityName, is_parameter_entity,
-              conv_string_len_to_utf8(value, value_length),
-              STRING_CONV_FUNC,base, STRING_CONV_FUNC,systemId,
-              STRING_CONV_FUNC,publicId, STRING_CONV_FUNC,notationName))
-#else
-VOID_HANDLER(EntityDecl,
-             (void *userData,
-              const XML_Char *entityName,
-              int is_parameter_entity,
-              const XML_Char *value,
-              int value_length,
-              const XML_Char *base,
-              const XML_Char *systemId,
-              const XML_Char *publicId,
-              const XML_Char *notationName),
-             ("O&iNO&O&O&O&",
-              STRING_CONV_FUNC,entityName, is_parameter_entity,
-              (self->returns_unicode 
-               ? conv_string_len_to_unicode(value, value_length) 
-               : conv_string_len_to_utf8(value, value_length)),
-              STRING_CONV_FUNC,base, STRING_CONV_FUNC,systemId,
-              STRING_CONV_FUNC,publicId, STRING_CONV_FUNC,notationName))
-#endif
-
-VOID_HANDLER(XmlDecl,
-             (void *userData,
-              const XML_Char *version,
-              const XML_Char *encoding,
-              int standalone),
-             ("(O&O&i)",
-              STRING_CONV_FUNC,version, STRING_CONV_FUNC,encoding, 
-              standalone))
-
-static PyObject *
-conv_content_model(XML_Content * const model,
-                   PyObject *(*conv_string)(XML_Char *))
-{
-    PyObject *result = NULL;
-    PyObject *children = PyTuple_New(model->numchildren);
-    int i;
-
-    if (children != NULL) {
-        assert(model->numchildren < INT_MAX);
-        for (i = 0; i < (int)model->numchildren; ++i) {
-            PyObject *child = conv_content_model(&model->children[i],
-                                                 conv_string);
-            if (child == NULL) {
-                Py_XDECREF(children);
-                return NULL;
-            }
-            PyTuple_SET_ITEM(children, i, child);
-        }
-        result = Py_BuildValue("(iiO&N)",
-                               model->type, model->quant,
-                               conv_string,model->name, children);
-    }
-    return result;
-}
-
-static void
-my_ElementDeclHandler(void *userData,
-                      const XML_Char *name,
-                      XML_Content *model)
-{
-    xmlparseobject *self = (xmlparseobject *)userData;
-    PyObject *args = NULL;
-
-    if (self->handlers[ElementDecl] != NULL
-        && self->handlers[ElementDecl] != Py_None) {
-        PyObject *rv = NULL;
-        PyObject *modelobj, *nameobj;
-
-#ifdef Py_USING_UNICODE
-        modelobj = conv_content_model(model,
-                                      (self->returns_unicode
-                                       ? conv_string_to_unicode
-                                       : conv_string_to_utf8));
-#else
-        modelobj = conv_content_model(model, conv_string_to_utf8);
-#endif
-        if (modelobj == NULL) {
-            flag_error(self);
-            goto finally;
-        }
-        nameobj = PyString_FromString(name);
-        if (nameobj == NULL) {
-            Py_DECREF(modelobj);
-            flag_error(self);
-            goto finally;
-        }
-        args = Py_BuildValue("NN", nameobj, modelobj);
-        if (args == NULL) {
-            Py_DECREF(modelobj);
-            flag_error(self);
-            goto finally;
-        }
-        self->in_callback = 1;
-        rv = call_with_frame(getcode(ElementDecl, "ElementDecl", __LINE__),
-                             self->handlers[ElementDecl], args);
-        self->in_callback = 0;
-        if (rv == NULL) {
-            flag_error(self);
-            goto finally;
-        }
-        Py_DECREF(rv);
-    }
- finally:
-    Py_XDECREF(args);
-    /* XML_FreeContentModel() was introduced in Expat 1.95.6. */
-#if EXPAT_VERSION >= 0x015f06
-    XML_FreeContentModel(self->itself, model);
-#else
-    free(model);
-#endif
-    return;
-}
-
-VOID_HANDLER(AttlistDecl,
-             (void *userData,
-              const XML_Char *elname,
-              const XML_Char *attname,
-              const XML_Char *att_type,
-              const XML_Char *dflt,
-              int isrequired),
-             ("(O&O&O&O&i)",
-              STRING_CONV_FUNC,elname, STRING_CONV_FUNC,attname,
-              STRING_CONV_FUNC,att_type, STRING_CONV_FUNC,dflt,
-              isrequired))
-#endif
-
-VOID_HANDLER(NotationDecl, 
-		(void *userData,
-			const XML_Char *notationName,
-			const XML_Char *base,
-			const XML_Char *systemId,
-			const XML_Char *publicId),
-                ("(O&O&O&O&)", 
-		 STRING_CONV_FUNC,notationName, STRING_CONV_FUNC,base, 
-		 STRING_CONV_FUNC,systemId, STRING_CONV_FUNC,publicId))
-
-VOID_HANDLER(StartNamespaceDecl,
-		(void *userData,
-		      const XML_Char *prefix,
-		      const XML_Char *uri),
-                ("(O&O&)", STRING_CONV_FUNC,prefix, STRING_CONV_FUNC,uri))
-
-VOID_HANDLER(EndNamespaceDecl,
-		(void *userData,
-		    const XML_Char *prefix),
-                ("(O&)", STRING_CONV_FUNC,prefix))
-
-VOID_HANDLER(Comment,
-               (void *userData, const XML_Char *prefix),
-                ("(O&)", STRING_CONV_FUNC,prefix))
-
-VOID_HANDLER(StartCdataSection,
-               (void *userData),
-		("()"))
-		
-VOID_HANDLER(EndCdataSection,
-               (void *userData),
-		("()"))
-
-#ifndef Py_USING_UNICODE
-VOID_HANDLER(Default,
-	      (void *userData,  const XML_Char *s, int len),
-	      ("(N)", conv_string_len_to_utf8(s,len)))
-
-VOID_HANDLER(DefaultHandlerExpand,
-	      (void *userData,  const XML_Char *s, int len),
-	      ("(N)", conv_string_len_to_utf8(s,len)))
-#else
-VOID_HANDLER(Default,
-	      (void *userData,  const XML_Char *s, int len),
-	      ("(N)", (self->returns_unicode 
-		       ? conv_string_len_to_unicode(s,len) 
-		       : conv_string_len_to_utf8(s,len))))
-
-VOID_HANDLER(DefaultHandlerExpand,
-	      (void *userData,  const XML_Char *s, int len),
-	      ("(N)", (self->returns_unicode 
-		       ? conv_string_len_to_unicode(s,len) 
-		       : conv_string_len_to_utf8(s,len))))
-#endif
-
-INT_HANDLER(NotStandalone, 
-		(void *userData), 
-		("()"))
-
-RC_HANDLER(int, ExternalEntityRef,
-		(XML_Parser parser,
-		    const XML_Char *context,
-		    const XML_Char *base,
-		    const XML_Char *systemId,
-		    const XML_Char *publicId),
-		int rc=0;,
-                ("(O&O&O&O&)", 
-		 STRING_CONV_FUNC,context, STRING_CONV_FUNC,base, 
-		 STRING_CONV_FUNC,systemId, STRING_CONV_FUNC,publicId),
-		rc = PyInt_AsLong(rv);, rc,
-		XML_GetUserData(parser))
-
-/* XXX UnknownEncodingHandler */
-
-#if EXPAT_VERSION == 0x010200
-VOID_HANDLER(StartDoctypeDecl,
-	     (void *userData, const XML_Char *doctypeName),
-	     ("(O&OOi)", STRING_CONV_FUNC,doctypeName,
-              Py_None, Py_None, -1))
-#elif EXPAT_VERSION >= 0x015f00
-VOID_HANDLER(StartDoctypeDecl,
-             (void *userData, const XML_Char *doctypeName,
-              const XML_Char *sysid, const XML_Char *pubid,
-              int has_internal_subset),
-             ("(O&O&O&i)", STRING_CONV_FUNC,doctypeName,
-              STRING_CONV_FUNC,sysid, STRING_CONV_FUNC,pubid,
-              has_internal_subset))
-#endif
-
-#if EXPAT_VERSION >= 0x010200
-VOID_HANDLER(EndDoctypeDecl, (void *userData), ("()"))
-#endif
-
-#if EXPAT_VERSION == 0x010200
-VOID_HANDLER(ExternalParsedEntityDecl,
-	     (void *userData, const XML_Char *entityName,
-	      const XML_Char *base, const XML_Char *systemId,
-	      const XML_Char *publicId),
-	     ("(O&O&O&O&)", STRING_CONV_FUNC, entityName,
-	      STRING_CONV_FUNC, base, STRING_CONV_FUNC, systemId,
-	      STRING_CONV_FUNC, publicId))
-
-VOID_HANDLER(InternalParsedEntityDecl,
-	     (void *userData, const XML_Char *entityName,
-	      const XML_Char *replacementText, int replacementTextLength),
-	     ("(O&O&i)", STRING_CONV_FUNC, entityName,
-	      STRING_CONV_FUNC, replacementText, replacementTextLength))
-
-#endif /* Expat version 1.2 & better */
-
-/* ---------------------------------------------------------------- */
-
-static char xmlparse_Parse__doc__[] = 
-"Parse(data[, isfinal])\n\
-Parse XML data.  `isfinal' should be true at end of input.";
-
-static PyObject *
-xmlparse_Parse(xmlparseobject *self, PyObject *args)
-{
-    char *s;
-    int slen;
-    int isFinal = 0;
-    int rv;
-
-    if (!PyArg_ParseTuple(args, "s#|i:Parse", &s, &slen, &isFinal))
-        return NULL;
-    rv = XML_Parse(self->itself, s, slen, isFinal);
-    if (PyErr_Occurred()) {	
-        return NULL;
-    }
-    else if (rv == 0) {
-        return set_error(self);
-    }
-    return PyInt_FromLong(rv);
-}
-
-/* File reading copied from cPickle */
-
-#define BUF_SIZE 2048
-
-static int
-readinst(char *buf, int buf_size, PyObject *meth)
-{
-    PyObject *arg = NULL;
-    PyObject *bytes = NULL;
-    PyObject *str = NULL;
-    int len = -1;
-
-    if ((bytes = PyInt_FromLong(buf_size)) == NULL)
-        goto finally;
-
-    if ((arg = PyTuple_New(1)) == NULL)
-        goto finally;
-
-    PyTuple_SET_ITEM(arg, 0, bytes);
-
-    if ((str = PyObject_CallObject(meth, arg)) == NULL)
-        goto finally;
-
-    /* XXX what to do if it returns a Unicode string? */
-    if (!PyString_Check(str)) {
-        PyErr_Format(PyExc_TypeError, 
-                     "read() did not return a string object (type=%.400s)",
-                     str->ob_type->tp_name);
-        goto finally;
-    }
-    len = PyString_GET_SIZE(str);
-    if (len > buf_size) {
-        PyErr_Format(PyExc_ValueError,
-                     "read() returned too much data: "
-                     "%i bytes requested, %i returned",
-                     buf_size, len);
-        Py_DECREF(str);
-        goto finally;
-    }
-    memcpy(buf, PyString_AsString(str), len);
-finally:
-    Py_XDECREF(arg);
-    Py_XDECREF(str);
-    return len;
-}
-
-static char xmlparse_ParseFile__doc__[] = 
-"ParseFile(file)\n\
-Parse XML data from file-like object.";
-
-static PyObject *
-xmlparse_ParseFile(xmlparseobject *self, PyObject *args)
-{
-    int rv = 1;
-    PyObject *f;
-    FILE *fp;
-    PyObject *readmethod = NULL;
-
-    if (!PyArg_ParseTuple(args, "O:ParseFile", &f))
-        return NULL;
-
-    if (PyFile_Check(f)) {
-        fp = PyFile_AsFile(f);
-    }
-    else{
-        fp = NULL;
-        readmethod = PyObject_GetAttrString(f, "read");
-        if (readmethod == NULL) {
-            PyErr_Clear();
-            PyErr_SetString(PyExc_TypeError, 
-                            "argument must have 'read' attribute");
-            return 0;
-        }
-    }
-    for (;;) {
-        int bytes_read;
-        void *buf = XML_GetBuffer(self->itself, BUF_SIZE);
-        if (buf == NULL)
-            return PyErr_NoMemory();
-
-        if (fp) {
-            bytes_read = fread(buf, sizeof(char), BUF_SIZE, fp);
-            if (bytes_read < 0) {
-                PyErr_SetFromErrno(PyExc_IOError);
-                return NULL;
-            }
-        }
-        else {
-            bytes_read = readinst(buf, BUF_SIZE, readmethod);
-            if (bytes_read < 0)
-                return NULL;
-        }
-        rv = XML_ParseBuffer(self->itself, bytes_read, bytes_read == 0);
-        if (PyErr_Occurred())
-            return NULL;
-
-        if (!rv || bytes_read == 0)
-            break;
-    }
-    if (rv == 0) {
-        return set_error(self);
-    }
-    return Py_BuildValue("i", rv);
-}
-
-static char xmlparse_SetBase__doc__[] = 
-"SetBase(base_url)\n\
-Set the base URL for the parser.";
-
-static PyObject *
-xmlparse_SetBase(xmlparseobject *self, PyObject *args)
-{
-    char *base;
-
-    if (!PyArg_ParseTuple(args, "s:SetBase", &base))
-        return NULL;
-    if (!XML_SetBase(self->itself, base)) {
-	return PyErr_NoMemory();
-    }
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char xmlparse_GetBase__doc__[] = 
-"GetBase() -> url\n\
-Return base URL string for the parser.";
-
-static PyObject *
-xmlparse_GetBase(xmlparseobject *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":GetBase"))
-        return NULL;
-
-    return Py_BuildValue("z", XML_GetBase(self->itself));
-}
-
-#if EXPAT_VERSION >= 0x015f00
-static char xmlparse_GetInputContext__doc__[] =
-"GetInputContext() -> string\n\
-Return the untranslated text of the input that caused the current event.\n\
-If the event was generated by a large amount of text (such as a start tag\n\
-for an element with many attributes), not all of the text may be available.";
-
-static PyObject *
-xmlparse_GetInputContext(xmlparseobject *self, PyObject *args)
-{
-    PyObject *result = NULL;
-
-    if (PyArg_ParseTuple(args, ":GetInputContext")) {
-        if (self->in_callback) {
-            int offset, size;
-            const char *buffer
-                = XML_GetInputContext(self->itself, &offset, &size);
-
-            if (buffer != NULL)
-                result = PyString_FromStringAndSize(buffer + offset, size);
-            else {
-                result = Py_None;
-                Py_INCREF(result);
-            }
-        }
-        else {
-            result = Py_None;
-            Py_INCREF(result);
-        }
-    }
-    return result;
-}
-#endif
-
-static char xmlparse_ExternalEntityParserCreate__doc__[] = 
-"ExternalEntityParserCreate(context[, encoding])\n\
-Create a parser for parsing an external entity based on the\n\
-information passed to the ExternalEntityRefHandler.";
-
-static PyObject *
-xmlparse_ExternalEntityParserCreate(xmlparseobject *self, PyObject *args)
-{
-    char *context;
-    char *encoding = NULL;
-    xmlparseobject *new_parser;
-    int i;
-
-    if (!PyArg_ParseTuple(args, "z|s:ExternalEntityParserCreate",
-                          &context, &encoding)) {
-        return NULL;
-    }
-
-#if PY_MAJOR_VERSION == 1 && PY_MINOR_VERSION < 6
-    new_parser = PyObject_NEW(xmlparseobject, &Xmlparsetype);
-#else
-#ifndef Py_TPFLAGS_HAVE_GC
-    /* Python versions 1.6 to 2.1 */
-    new_parser = PyObject_New(xmlparseobject, &Xmlparsetype);
-#else
-    /* Python versions 2.2 and later */
-    new_parser = PyObject_GC_New(xmlparseobject, &Xmlparsetype);
-#endif
-#endif
-
-    if (new_parser == NULL)
-        return NULL;
-    new_parser->returns_unicode = self->returns_unicode;
-    new_parser->ordered_attributes = self->ordered_attributes;
-    new_parser->specified_attributes = self->specified_attributes;
-    new_parser->in_callback = 0;
-    new_parser->itself = XML_ExternalEntityParserCreate(self->itself, context,
-							encoding);
-    new_parser->handlers = 0;
-#ifdef Py_TPFLAGS_HAVE_GC
-    PyObject_GC_Track(new_parser);
-#else
-    PyObject_GC_Init(new_parser);
-#endif
-
-    if (!new_parser->itself) {
-        Py_DECREF(new_parser);
-        return PyErr_NoMemory();
-    }
-
-    XML_SetUserData(new_parser->itself, (void *)new_parser);
-
-    /* allocate and clear handlers first */
-    for(i = 0; handler_info[i].name != NULL; i++)
-        /* do nothing */;
-
-    new_parser->handlers = malloc(sizeof(PyObject *)*i);
-    if (!new_parser->handlers) {
-        Py_DECREF(new_parser);
-        return PyErr_NoMemory();
-    }
-    clear_handlers(new_parser, 1);
-
-    /* then copy handlers from self */
-    for (i = 0; handler_info[i].name != NULL; i++) {
-        if (self->handlers[i]) {
-            Py_INCREF(self->handlers[i]);
-            new_parser->handlers[i] = self->handlers[i];
-            handler_info[i].setter(new_parser->itself, 
-                                   handler_info[i].handler);
-        }
-    }
-    return (PyObject *)new_parser;    
-}
-
-#if EXPAT_VERSION >= 0x010200
-
-static char xmlparse_SetParamEntityParsing__doc__[] =
-"SetParamEntityParsing(flag) -> success\n\
-Controls parsing of parameter entities (including the external DTD\n\
-subset). Possible flag values are XML_PARAM_ENTITY_PARSING_NEVER,\n\
-XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE and\n\
-XML_PARAM_ENTITY_PARSING_ALWAYS. Returns true if setting the flag\n\
-was successful.";
-
-static PyObject*
-xmlparse_SetParamEntityParsing(xmlparseobject *p, PyObject* args)
-{
-    int flag;
-    if (!PyArg_ParseTuple(args, "i", &flag))
-        return NULL;
-    flag = XML_SetParamEntityParsing(p->itself, flag);
-    return PyInt_FromLong(flag);
-}
-
-#endif /* Expat version 1.2 or better */
-
-static struct PyMethodDef xmlparse_methods[] = {
-    {"Parse",	  (PyCFunction)xmlparse_Parse,
-		  METH_VARARGS,	xmlparse_Parse__doc__},
-    {"ParseFile", (PyCFunction)xmlparse_ParseFile,
-		  METH_VARARGS,	xmlparse_ParseFile__doc__},
-    {"SetBase",   (PyCFunction)xmlparse_SetBase,
-		  METH_VARARGS,      xmlparse_SetBase__doc__},
-    {"GetBase",   (PyCFunction)xmlparse_GetBase,
-		  METH_VARARGS,      xmlparse_GetBase__doc__},
-    {"ExternalEntityParserCreate", (PyCFunction)xmlparse_ExternalEntityParserCreate,
-	 	  METH_VARARGS,      xmlparse_ExternalEntityParserCreate__doc__},
-#if EXPAT_VERSION >= 0x010200
-    {"SetParamEntityParsing", (PyCFunction)xmlparse_SetParamEntityParsing,
-		  METH_VARARGS, xmlparse_SetParamEntityParsing__doc__},
-#endif
-#if EXPAT_VERSION >= 0x015f00
-    {"GetInputContext", (PyCFunction)xmlparse_GetInputContext,
-		  METH_VARARGS, xmlparse_GetInputContext__doc__},
-#endif
-	{NULL,		NULL}		/* sentinel */
-};
-
-/* ---------- */
-
-
-#ifdef Py_USING_UNICODE
-
-/* 
-    pyexpat international encoding support.
-    Make it as simple as possible.
-*/
-
-static char template_buffer[257];
-PyObject *template_string = NULL;
-
-static void 
-init_template_buffer(void)
-{
-    int i;
-    for (i = 0; i < 256; i++) {
-	template_buffer[i] = i;
-    }
-    template_buffer[256] = 0;
-}
-
-int 
-PyUnknownEncodingHandler(void *encodingHandlerData, 
-const XML_Char *name, 
-XML_Encoding * info)
-{
-    PyUnicodeObject *_u_string = NULL;
-    int result = 0;
-    int i;
-    
-    /* Yes, supports only 8bit encodings */
-    _u_string = (PyUnicodeObject *)
-        PyUnicode_Decode(template_buffer, 256, name, "replace");
-    
-    if (_u_string == NULL)
-	return result;
-    
-    for (i = 0; i < 256; i++) {
-	/* Stupid to access directly, but fast */
-	Py_UNICODE c = _u_string->str[i];
-	if (c == Py_UNICODE_REPLACEMENT_CHARACTER)
-	    info->map[i] = -1;
-	else
-	    info->map[i] = c;
-    }
-    
-    info->data = NULL;
-    info->convert = NULL;
-    info->release = NULL;
-    result=1;
-    
-    Py_DECREF(_u_string);
-    return result;
-}
-
-#endif
-
-static PyObject *
-newxmlparseobject(char *encoding, char *namespace_separator)
-{
-    int i;
-    xmlparseobject *self;
-	
-#if PY_MAJOR_VERSION == 1 && PY_MINOR_VERSION < 6
-    self = PyObject_NEW(xmlparseobject, &Xmlparsetype);
-    if (self == NULL)
-        return NULL;
-
-    self->returns_unicode = 0;
-#else
-    /* Code for versions 1.6 and later */
-#ifdef Py_TPFLAGS_HAVE_GC
-    /* Code for versions 2.2 and later */
-    self = PyObject_GC_New(xmlparseobject, &Xmlparsetype);
-#else
-    self = PyObject_New(xmlparseobject, &Xmlparsetype);
-#endif
-    if (self == NULL)
-        return NULL;
-
-    self->returns_unicode = 1;
-#endif
-    self->ordered_attributes = 0;
-    self->specified_attributes = 0;
-    self->in_callback = 0;
-    self->handlers = NULL;
-    if (namespace_separator != NULL) {
-        self->itself = XML_ParserCreateNS(encoding, *namespace_separator);
-    }
-    else {
-        self->itself = XML_ParserCreate(encoding);
-    }
-#ifdef Py_TPFLAGS_HAVE_GC
-    PyObject_GC_Track(self);
-#else
-    PyObject_GC_Init(self);
-#endif
-    if (self->itself == NULL) {
-        PyErr_SetString(PyExc_RuntimeError, 
-                        "XML_ParserCreate failed");
-        Py_DECREF(self);
-        return NULL;
-    }
-    XML_SetUserData(self->itself, (void *)self);
-#ifdef Py_USING_UNICODE
-    XML_SetUnknownEncodingHandler(self->itself, (XML_UnknownEncodingHandler) PyUnknownEncodingHandler, NULL);
-#endif
-
-    for(i = 0; handler_info[i].name != NULL; i++)
-        /* do nothing */;
-
-    self->handlers = malloc(sizeof(PyObject *)*i);
-    if (!self->handlers){
-	    Py_DECREF(self);
-	    return PyErr_NoMemory();
-    }
-    clear_handlers(self, 1);
-
-    return (PyObject*)self;
-}
-
-
-static void
-xmlparse_dealloc(xmlparseobject *self)
-{
-    int i;
-#ifdef Py_TPFLAGS_HAVE_GC
-    PyObject_GC_UnTrack(self);
-#else
-    PyObject_GC_Fini(self);
-#endif
-    if (self->itself != NULL)
-        XML_ParserFree(self->itself);
-    self->itself = NULL;
-
-    if (self->handlers != NULL) {
-        PyObject *temp;
-        for (i = 0; handler_info[i].name != NULL; i++) {
-            temp = self->handlers[i];
-            self->handlers[i] = NULL;
-            Py_XDECREF(temp);
-        }
-        free(self->handlers);
-    }
-#if PY_MAJOR_VERSION == 1 && PY_MINOR_VERSION < 6
-    /* Code for versions before 1.6 */
-    free(self);
-#else
-#ifndef Py_TPFLAGS_HAVE_GC
-    /* Code for versions 1.6 to 2.1 */
-    PyObject_Del(self);
-#else
-    /* Code for versions 2.2 and later. */
-    PyObject_GC_Del(self);
-#endif
-#endif
-}
-
-static int
-handlername2int(const char *name)
-{
-    int i;
-    for (i=0; handler_info[i].name != NULL; i++) {
-        if (strcmp(name, handler_info[i].name) == 0) {
-            return i;
-        }
-    }
-    return -1;
-}
-
-static PyObject *
-xmlparse_getattr(xmlparseobject *self, char *name)
-{
-    int handlernum;
-    if (strcmp(name, "ErrorCode") == 0)
-        return PyInt_FromLong((long) XML_GetErrorCode(self->itself));
-    if (strcmp(name, "ErrorLineNumber") == 0)
-        return PyInt_FromLong((long) XML_GetErrorLineNumber(self->itself));
-    if (strcmp(name, "ErrorColumnNumber") == 0)
-        return PyInt_FromLong((long) XML_GetErrorColumnNumber(self->itself));
-    if (strcmp(name, "ErrorByteIndex") == 0)
-        return PyInt_FromLong((long) XML_GetErrorByteIndex(self->itself));
-    if (strcmp(name, "ordered_attributes") == 0)
-        return PyInt_FromLong((long) self->ordered_attributes);
-    if (strcmp(name, "returns_unicode") == 0)
-        return PyInt_FromLong((long) self->returns_unicode);
-    if (strcmp(name, "specified_attributes") == 0)
-        return PyInt_FromLong((long) self->specified_attributes);
-
-    handlernum = handlername2int(name);
-
-    if (handlernum != -1 && self->handlers[handlernum] != NULL) {
-        Py_INCREF(self->handlers[handlernum]);
-        return self->handlers[handlernum];
-    }
-
-#define APPEND(list, str)				\
-	do {						\
-		PyObject *o = PyString_FromString(str);	\
-		if (o != NULL)				\
-			PyList_Append(list, o);		\
-		Py_XDECREF(o);				\
-	} while (0)
-
-    if (strcmp(name, "__members__") == 0) {
-        int i;
-        PyObject *rc = PyList_New(0);
-        for (i = 0; handler_info[i].name != NULL; i++) {
-            APPEND(rc, handler_info[i].name);
-        }
-        APPEND(rc, "ErrorCode");
-        APPEND(rc, "ErrorLineNumber");
-        APPEND(rc, "ErrorColumnNumber");
-        APPEND(rc, "ErrorByteIndex");
-        APPEND(rc, "ordered_attributes");
-        APPEND(rc, "returns_unicode");
-        APPEND(rc, "specified_attributes");
-
-#undef APPEND
-        return rc;
-    }
-    return Py_FindMethod(xmlparse_methods, (PyObject *)self, name);
-}
-
-static int
-sethandler(xmlparseobject *self, const char *name, PyObject* v)
-{
-    int handlernum = handlername2int(name);
-    if (handlernum != -1) {
-        Py_INCREF(v);
-        Py_XDECREF(self->handlers[handlernum]);
-        self->handlers[handlernum] = v;
-        handler_info[handlernum].setter(self->itself, 
-                                        handler_info[handlernum].handler);
-        return 1;
-    }
-    return 0;
-}
-
-static int
-xmlparse_setattr(xmlparseobject *self, char *name, PyObject *v)
-{
-    /* Set attribute 'name' to value 'v'. v==NULL means delete */
-    if (v == NULL) {
-        PyErr_SetString(PyExc_RuntimeError, "Cannot delete attribute");
-        return -1;
-    }
-    if (strcmp(name, "ordered_attributes") == 0) {
-        if (PyObject_IsTrue(v))
-            self->ordered_attributes = 1;
-        else
-            self->ordered_attributes = 0;
-        return 0;
-    }
-    if (strcmp(name, "returns_unicode") == 0) {
-        if (PyObject_IsTrue(v)) {
-#ifndef Py_USING_UNICODE
-            PyErr_SetString(PyExc_ValueError, 
-                            "Cannot return Unicode strings in Python 1.5");
-            return -1;
-#else
-            self->returns_unicode = 1;
-#endif
-        }
-        else
-            self->returns_unicode = 0;
-        return 0;
-    }
-    if (strcmp(name, "specified_attributes") == 0) {
-        if (PyObject_IsTrue(v))
-            self->specified_attributes = 1;
-        else
-            self->specified_attributes = 0;
-        return 0;
-    }
-    if (sethandler(self, name, v)) {
-        return 0;
-    }
-    PyErr_SetString(PyExc_AttributeError, name);
-    return -1;
-}
-
-#ifdef WITH_CYCLE_GC
-static int
-xmlparse_traverse(xmlparseobject *op, visitproc visit, void *arg)
-{
-    int i, err;
-    for (i = 0; handler_info[i].name != NULL; i++) {
-        if (!op->handlers[i])
-            continue;
-        err = visit(op->handlers[i], arg);
-        if (err)
-            return err;
-    }
-    return 0;
-}
-
-static int
-xmlparse_clear(xmlparseobject *op)
-{
-    clear_handlers(op, 0);
-    return 0;
-}
-#endif
-
-static char Xmlparsetype__doc__[] = 
-"XML parser";
-
-static PyTypeObject Xmlparsetype = {
-	PyObject_HEAD_INIT(NULL)
-	0,				/*ob_size*/
-	"pyexpat.xmlparser",		/*tp_name*/
-	sizeof(xmlparseobject) + PyGC_HEAD_SIZE,/*tp_basicsize*/
-	0,				/*tp_itemsize*/
-	/* methods */
-	(destructor)xmlparse_dealloc,	/*tp_dealloc*/
-	(printfunc)0,		/*tp_print*/
-	(getattrfunc)xmlparse_getattr,	/*tp_getattr*/
-	(setattrfunc)xmlparse_setattr,	/*tp_setattr*/
-	(cmpfunc)0,		/*tp_compare*/
-	(reprfunc)0,		/*tp_repr*/
-	0,			/*tp_as_number*/
-	0,		/*tp_as_sequence*/
-	0,		/*tp_as_mapping*/
-	(hashfunc)0,		/*tp_hash*/
-	(ternaryfunc)0,		/*tp_call*/
-	(reprfunc)0,		/*tp_str*/
-	0,		/* tp_getattro */
-	0,		/* tp_setattro */
-	0,		/* tp_as_buffer */
-#ifdef Py_TPFLAGS_HAVE_GC
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /*tp_flags*/	
-#else
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_GC, /*tp_flags*/	
-#endif
-	Xmlparsetype__doc__, /* Documentation string */
-#ifdef WITH_CYCLE_GC
-	(traverseproc)xmlparse_traverse,	/* tp_traverse */
-	(inquiry)xmlparse_clear		/* tp_clear */
-#else
-	0, 0
-#endif
-};
-
-/* End of code for xmlparser objects */
-/* -------------------------------------------------------- */
-
-static char pyexpat_ParserCreate__doc__[] =
-"ParserCreate([encoding[, namespace_separator]]) -> parser\n\
-Return a new XML parser object.";
-
-static PyObject *
-pyexpat_ParserCreate(PyObject *notused, PyObject *args, PyObject *kw)
-{
-    char *encoding = NULL;
-    char *namespace_separator = NULL;
-    static char *kwlist[] = {"encoding", "namespace_separator", NULL};
-
-    if (!PyArg_ParseTupleAndKeywords(args, kw, "|zz:ParserCreate", kwlist,
-                                     &encoding, &namespace_separator))
-        return NULL;
-    if (namespace_separator != NULL
-        && strlen(namespace_separator) > 1) {
-        PyErr_SetString(PyExc_ValueError,
-                        "namespace_separator must be at most one"
-                        " character, omitted, or None");
-        return NULL;
-    }
-    return newxmlparseobject(encoding, namespace_separator);
-}
-
-static char pyexpat_ErrorString__doc__[] =
-"ErrorString(errno) -> string\n\
-Returns string error for given number.";
-
-static PyObject *
-pyexpat_ErrorString(PyObject *self, PyObject *args)
-{
-    long code = 0;
-
-    if (!PyArg_ParseTuple(args, "l:ErrorString", &code))
-        return NULL;
-    return Py_BuildValue("z", XML_ErrorString((int)code));
-}
-
-/* List of methods defined in the module */
-
-static struct PyMethodDef pyexpat_methods[] = {
-    {"ParserCreate",	(PyCFunction)pyexpat_ParserCreate,
-     METH_VARARGS|METH_KEYWORDS, pyexpat_ParserCreate__doc__},
-    {"ErrorString",	(PyCFunction)pyexpat_ErrorString,
-     METH_VARARGS,	pyexpat_ErrorString__doc__},
- 
-    {NULL,	 (PyCFunction)NULL, 0, NULL}		/* sentinel */
-};
-
-/* Module docstring */
-
-static char pyexpat_module_documentation[] = 
-"Python wrapper for Expat parser.";
-
-#if PY_VERSION_HEX < 0x20000F0
-
-/* 1.5 compatibility: PyModule_AddObject */
-static int
-PyModule_AddObject(PyObject *m, char *name, PyObject *o)
-{
-    PyObject *dict;
-    if (!PyModule_Check(m) || o == NULL)
-        return -1;
-    dict = PyModule_GetDict(m);
-    if (dict == NULL)
-        return -1;
-    if (PyDict_SetItemString(dict, name, o))
-        return -1;
-    Py_DECREF(o);
-    return 0;
-}
-
-int 
-PyModule_AddIntConstant(PyObject *m, char *name, long value)
-{
-    return PyModule_AddObject(m, name, PyInt_FromLong(value));
-}
-
-static int 
-PyModule_AddStringConstant(PyObject *m, char *name, char *value)
-{
-    return PyModule_AddObject(m, name, PyString_FromString(value));
-}
-
-#endif
-
-
-/* Return a Python string that represents the version number without the
- * extra cruft added by revision control, even if the right options were
- * given to the "cvs export" command to make it not include the extra
- * cruft.
- */
-static PyObject *
-get_version_string(void)
-{
-    static char *rcsid = "$Revision: 2.57.6.6 $";
-    char *rev = rcsid;
-    int i = 0;
-
-    while (!isdigit(*rev))
-        ++rev;
-    while (rev[i] != ' ' && rev[i] != '\0')
-        ++i;
-
-    return PyString_FromStringAndSize(rev, i);
-}
-
-/* Initialization function for the module */
-
-#ifndef MODULE_NAME
-#define MODULE_NAME "pyexpat"
-#endif
-
-#ifndef MODULE_INITFUNC
-#define MODULE_INITFUNC initpyexpat
-#endif
-
-void MODULE_INITFUNC(void);  /* avoid compiler warnings */
-
-DL_EXPORT(void)
-MODULE_INITFUNC(void)
-{
-    PyObject *m, *d;
-    PyObject *errmod_name = PyString_FromString(MODULE_NAME ".errors");
-    PyObject *errors_module;
-    PyObject *modelmod_name;
-    PyObject *model_module;
-    PyObject *sys_modules;
-
-    if (errmod_name == NULL)
-        return;
-    modelmod_name = PyString_FromString(MODULE_NAME ".model");
-    if (modelmod_name == NULL)
-        return;
-
-    Xmlparsetype.ob_type = &PyType_Type;
-
-    /* Create the module and add the functions */
-    m = Py_InitModule3(MODULE_NAME, pyexpat_methods,
-                       pyexpat_module_documentation);
-
-    /* Add some symbolic constants to the module */
-    if (ErrorObject == NULL) {
-        ErrorObject = PyErr_NewException("xml.parsers.expat.ExpatError",
-                                         NULL, NULL);
-        if (ErrorObject == NULL)
-            return;
-    }
-    Py_INCREF(ErrorObject);
-    PyModule_AddObject(m, "error", ErrorObject);
-    Py_INCREF(ErrorObject);
-    PyModule_AddObject(m, "ExpatError", ErrorObject);
-    Py_INCREF(&Xmlparsetype);
-    PyModule_AddObject(m, "XMLParserType", (PyObject *) &Xmlparsetype);
-
-    PyModule_AddObject(m, "__version__", get_version_string());
-#if EXPAT_VERSION >= 0x015f02
-    PyModule_AddStringConstant(m, "EXPAT_VERSION",
-                               (char *) XML_ExpatVersion());
-    {
-        XML_Expat_Version info = XML_ExpatVersionInfo();
-        PyModule_AddObject(m, "version_info",
-                           Py_BuildValue("(iii)", info.major,
-                                         info.minor, info.micro));
-    }
-#endif
-#ifdef Py_USING_UNICODE
-    init_template_buffer();
-#endif
-    /* XXX When Expat supports some way of figuring out how it was
-       compiled, this should check and set native_encoding 
-       appropriately. 
-    */
-    PyModule_AddStringConstant(m, "native_encoding", "UTF-8");
-
-    sys_modules = PySys_GetObject("modules");
-    d = PyModule_GetDict(m);
-    errors_module = PyDict_GetItem(d, errmod_name);
-    if (errors_module == NULL) {
-        errors_module = PyModule_New(MODULE_NAME ".errors");
-        if (errors_module != NULL) {
-            PyDict_SetItem(sys_modules, errmod_name, errors_module);
-            /* gives away the reference to errors_module */
-            PyModule_AddObject(m, "errors", errors_module);
-        }
-    }
-    Py_DECREF(errmod_name);
-    model_module = PyDict_GetItem(d, modelmod_name);
-    if (model_module == NULL) {
-        model_module = PyModule_New(MODULE_NAME ".model");
-        if (model_module != NULL) {
-            PyDict_SetItem(sys_modules, modelmod_name, model_module);
-            /* gives away the reference to model_module */
-            PyModule_AddObject(m, "model", model_module);
-        }
-    }
-    Py_DECREF(modelmod_name);
-    if (errors_module == NULL || model_module == NULL)
-        /* Don't core dump later! */
-        return;
-
-#define MYCONST(name) \
-    PyModule_AddStringConstant(errors_module, #name, \
-                               (char*)XML_ErrorString(name))
-
-    MYCONST(XML_ERROR_NO_MEMORY);
-    MYCONST(XML_ERROR_SYNTAX);
-    MYCONST(XML_ERROR_NO_ELEMENTS);
-    MYCONST(XML_ERROR_INVALID_TOKEN);
-    MYCONST(XML_ERROR_UNCLOSED_TOKEN);
-    MYCONST(XML_ERROR_PARTIAL_CHAR);
-    MYCONST(XML_ERROR_TAG_MISMATCH);
-    MYCONST(XML_ERROR_DUPLICATE_ATTRIBUTE);
-    MYCONST(XML_ERROR_JUNK_AFTER_DOC_ELEMENT);
-    MYCONST(XML_ERROR_PARAM_ENTITY_REF);
-    MYCONST(XML_ERROR_UNDEFINED_ENTITY);
-    MYCONST(XML_ERROR_RECURSIVE_ENTITY_REF);
-    MYCONST(XML_ERROR_ASYNC_ENTITY);
-    MYCONST(XML_ERROR_BAD_CHAR_REF);
-    MYCONST(XML_ERROR_BINARY_ENTITY_REF);
-    MYCONST(XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF);
-    MYCONST(XML_ERROR_MISPLACED_XML_PI);
-    MYCONST(XML_ERROR_UNKNOWN_ENCODING);
-    MYCONST(XML_ERROR_INCORRECT_ENCODING);
-    MYCONST(XML_ERROR_UNCLOSED_CDATA_SECTION);
-    MYCONST(XML_ERROR_EXTERNAL_ENTITY_HANDLING);
-    MYCONST(XML_ERROR_NOT_STANDALONE);
-
-    PyModule_AddStringConstant(errors_module, "__doc__",
-                               "Constants used to describe error conditions.");
-
-#undef MYCONST
-
-#if EXPAT_VERSION >= 0x010200
-#define MYCONST(c) PyModule_AddIntConstant(m, #c, c)
-    MYCONST(XML_PARAM_ENTITY_PARSING_NEVER);
-    MYCONST(XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE);
-    MYCONST(XML_PARAM_ENTITY_PARSING_ALWAYS);
-#undef MYCONST
-#endif
-
-#if EXPAT_VERSION >= 0x015f00
-#define MYCONST(c) PyModule_AddIntConstant(model_module, #c, c)
-    PyModule_AddStringConstant(model_module, "__doc__",
-                     "Constants used to interpret content model information.");
-
-    MYCONST(XML_CTYPE_EMPTY);
-    MYCONST(XML_CTYPE_ANY);
-    MYCONST(XML_CTYPE_MIXED);
-    MYCONST(XML_CTYPE_NAME);
-    MYCONST(XML_CTYPE_CHOICE);
-    MYCONST(XML_CTYPE_SEQ);
-
-    MYCONST(XML_CQUANT_NONE);
-    MYCONST(XML_CQUANT_OPT);
-    MYCONST(XML_CQUANT_REP);
-    MYCONST(XML_CQUANT_PLUS);
-#undef MYCONST
-#endif
-}
-
-static void
-clear_handlers(xmlparseobject *self, int initial)
-{
-    int i = 0;
-    PyObject *temp;
-
-    for (; handler_info[i].name!=NULL; i++) {
-        if (initial)
-	    self->handlers[i]=NULL;
-	else {
-            temp = self->handlers[i];
-            self->handlers[i] = NULL;
-            Py_XDECREF(temp);
-	    handler_info[i].setter(self->itself, NULL);
-        }
-    }
-}
-
-typedef void (*pairsetter)(XML_Parser, void *handler1, void *handler2);
-
-static void
-pyxml_UpdatePairedHandlers(xmlparseobject *self, 
-                           int startHandler, 
-                           int endHandler,
-                           pairsetter setter)
-{
-    void *start_handler = NULL;
-    void *end_handler = NULL;
-
-    if (self->handlers[startHandler]
-        && self->handlers[startHandler] != Py_None) {
-        start_handler = handler_info[startHandler].handler;
-    }
-    if (self->handlers[endHandler]
-        && self->handlers[endHandler] != Py_None) {
-        end_handler = handler_info[endHandler].handler;
-    }
-    setter(self->itself, start_handler, end_handler);
-}
-
-static void
-pyxml_SetStartElementHandler(XML_Parser parser, void *junk)
-{
-    pyxml_UpdatePairedHandlers((xmlparseobject *)XML_GetUserData(parser),
-                               StartElement, EndElement,
-                               (pairsetter)XML_SetElementHandler);
-}
-
-static void
-pyxml_SetEndElementHandler(XML_Parser parser, void *junk)
-{
-    pyxml_UpdatePairedHandlers((xmlparseobject *)XML_GetUserData(parser), 
-                               StartElement, EndElement,
-                               (pairsetter)XML_SetElementHandler);
-}
-
-static void
-pyxml_SetStartNamespaceDeclHandler(XML_Parser parser, void *junk)
-{
-    pyxml_UpdatePairedHandlers((xmlparseobject *)XML_GetUserData(parser), 
-                               StartNamespaceDecl, EndNamespaceDecl,
-                               (pairsetter)XML_SetNamespaceDeclHandler);
-}
-
-static void
-pyxml_SetEndNamespaceDeclHandler(XML_Parser parser, void *junk)
-{
-    pyxml_UpdatePairedHandlers((xmlparseobject *)XML_GetUserData(parser), 
-                               StartNamespaceDecl, EndNamespaceDecl,
-                               (pairsetter)XML_SetNamespaceDeclHandler);
-}
-
-static void
-pyxml_SetStartCdataSection(XML_Parser parser, void *junk)
-{
-    pyxml_UpdatePairedHandlers((xmlparseobject *)XML_GetUserData(parser),
-                               StartCdataSection, EndCdataSection,
-                               (pairsetter)XML_SetCdataSectionHandler);
-}
-
-static void
-pyxml_SetEndCdataSection(XML_Parser parser, void *junk)
-{
-    pyxml_UpdatePairedHandlers((xmlparseobject *)XML_GetUserData(parser), 
-                               StartCdataSection, EndCdataSection, 
-                               (pairsetter)XML_SetCdataSectionHandler);
-}
-
-#if EXPAT_VERSION >= 0x010200
-
-static void
-pyxml_SetStartDoctypeDeclHandler(XML_Parser parser, void *junk)
-{
-    pyxml_UpdatePairedHandlers((xmlparseobject *)XML_GetUserData(parser),
-                               StartDoctypeDecl, EndDoctypeDecl,
-                               (pairsetter)XML_SetDoctypeDeclHandler);
-}
-
-static void
-pyxml_SetEndDoctypeDeclHandler(XML_Parser parser, void *junk)
-{
-    pyxml_UpdatePairedHandlers((xmlparseobject *)XML_GetUserData(parser),
-                               StartDoctypeDecl, EndDoctypeDecl,
-                               (pairsetter)XML_SetDoctypeDeclHandler);
-}
-
-#endif
-
-statichere struct HandlerInfo handler_info[] = {
-    {"StartElementHandler", 
-     pyxml_SetStartElementHandler, 
-     (xmlhandler)my_StartElementHandler},
-    {"EndElementHandler", 
-     pyxml_SetEndElementHandler, 
-     (xmlhandler)my_EndElementHandler},
-    {"ProcessingInstructionHandler", 
-     (xmlhandlersetter)XML_SetProcessingInstructionHandler,
-     (xmlhandler)my_ProcessingInstructionHandler},
-    {"CharacterDataHandler", 
-     (xmlhandlersetter)XML_SetCharacterDataHandler,
-     (xmlhandler)my_CharacterDataHandler},
-    {"UnparsedEntityDeclHandler", 
-     (xmlhandlersetter)XML_SetUnparsedEntityDeclHandler,
-     (xmlhandler)my_UnparsedEntityDeclHandler },
-    {"NotationDeclHandler", 
-     (xmlhandlersetter)XML_SetNotationDeclHandler,
-     (xmlhandler)my_NotationDeclHandler },
-    {"StartNamespaceDeclHandler", 
-     pyxml_SetStartNamespaceDeclHandler,
-     (xmlhandler)my_StartNamespaceDeclHandler },
-    {"EndNamespaceDeclHandler", 
-     pyxml_SetEndNamespaceDeclHandler,
-     (xmlhandler)my_EndNamespaceDeclHandler },
-    {"CommentHandler",
-     (xmlhandlersetter)XML_SetCommentHandler,
-     (xmlhandler)my_CommentHandler},
-    {"StartCdataSectionHandler",
-     pyxml_SetStartCdataSection,
-     (xmlhandler)my_StartCdataSectionHandler},
-    {"EndCdataSectionHandler",
-     pyxml_SetEndCdataSection,
-     (xmlhandler)my_EndCdataSectionHandler},
-    {"DefaultHandler",
-     (xmlhandlersetter)XML_SetDefaultHandler,
-     (xmlhandler)my_DefaultHandler},
-    {"DefaultHandlerExpand",
-     (xmlhandlersetter)XML_SetDefaultHandlerExpand,
-     (xmlhandler)my_DefaultHandlerExpandHandler},
-    {"NotStandaloneHandler",
-     (xmlhandlersetter)XML_SetNotStandaloneHandler,
-     (xmlhandler)my_NotStandaloneHandler},
-    {"ExternalEntityRefHandler",
-     (xmlhandlersetter)XML_SetExternalEntityRefHandler,
-     (xmlhandler)my_ExternalEntityRefHandler },
-#if EXPAT_VERSION >= 0x010200
-    {"StartDoctypeDeclHandler",
-     pyxml_SetStartDoctypeDeclHandler,
-     (xmlhandler)my_StartDoctypeDeclHandler},
-    {"EndDoctypeDeclHandler",
-     pyxml_SetEndDoctypeDeclHandler,
-     (xmlhandler)my_EndDoctypeDeclHandler},
-#endif
-#if EXPAT_VERSION == 0x010200
-    {"ExternalParsedEntityDeclHandler",
-     (xmlhandlersetter)XML_SetExternalParsedEntityDeclHandler,
-     (xmlhandler)my_ExternalParsedEntityDeclHandler},
-    {"InternalParsedEntityDeclHandler",
-     (xmlhandlersetter)XML_SetInternalParsedEntityDeclHandler,
-     (xmlhandler)my_InternalParsedEntityDeclHandler},
-#endif
-#if EXPAT_VERSION >= 0x015f00
-    {"EntityDeclHandler",
-     (xmlhandlersetter)XML_SetEntityDeclHandler,
-     (xmlhandler)my_EntityDeclHandler},
-    {"XmlDeclHandler",
-     (xmlhandlersetter)XML_SetXmlDeclHandler,
-     (xmlhandler)my_XmlDeclHandler},
-    {"ElementDeclHandler",
-     (xmlhandlersetter)XML_SetElementDeclHandler,
-     (xmlhandler)my_ElementDeclHandler},
-    {"AttlistDeclHandler",
-     (xmlhandlersetter)XML_SetAttlistDeclHandler,
-     (xmlhandler)my_AttlistDeclHandler},
-#endif /* Expat version 1.95 or better */
-
-    {NULL, NULL, NULL} /* sentinel */
-};
diff -r -u -N --strip-trailing-cr pyexpat-2.2.3-orig/src/pyexpat.cpp pyexpat-2.2.3-patched/src/pyexpat.cpp
--- pyexpat-2.2.3-orig/src/pyexpat.cpp	1970-01-01 02:00:00.000000000 +0200
+++ pyexpat-2.2.3-patched/src/pyexpat.cpp	2006-11-06 14:09:59.000000000 +0200
@@ -0,0 +1,1986 @@
+#include <Python.h>
+#include <symbian_python_ext_util.h>
+
+extern "C" {
+
+#if PY_VERSION_HEX < 0x020000B1
+#include <assert.h>
+#endif
+#include <ctype.h>
+
+#include "compile.h"
+#include "frameobject.h"
+#ifdef HAVE_EXPAT_H
+#include "expat.h"
+#ifdef XML_MAJOR_VERSION
+#define EXPAT_VERSION (0x10000 * XML_MAJOR_VERSION \
+                       + 0x100 * XML_MINOR_VERSION \
+                       + XML_MICRO_VERSION)
+#else
+/* Assume the oldest Expat that used expat.h and did not have version info */
+#define EXPAT_VERSION 0x015f00
+#endif
+#else /* !defined(HAVE_EXPAT_H) */
+#include "xmlparse.h"
+/* Assume Expat 1.1 unless told otherwise */
+#ifndef EXPAT_VERSION
+#define EXPAT_VERSION 0x010100
+#endif
+#endif /* !defined(HAVE_EXPAT_H) */
+
+#ifndef PyGC_HEAD_SIZE
+#define PyGC_HEAD_SIZE 0
+#define PyObject_GC_Init(x)
+#define PyObject_GC_Fini(m)
+#define Py_TPFLAGS_GC 0
+#endif
+
+#if (PY_MAJOR_VERSION == 1 && PY_MINOR_VERSION > 5) || (PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION < 2)
+/* In Python 1.6, 2.0 and  2.1, disabling Unicode was not possible. */
+#define Py_USING_UNICODE
+#endif
+
+enum HandlerTypes {
+    StartElement,
+    EndElement,
+    ProcessingInstruction,
+    CharacterData,
+    UnparsedEntityDecl,
+    NotationDecl,
+    StartNamespaceDecl,
+    EndNamespaceDecl,
+    Comment,
+    StartCdataSection,
+    EndCdataSection,
+    Default,
+    DefaultHandlerExpand,
+    NotStandalone,
+    ExternalEntityRef,
+#if EXPAT_VERSION >= 0x010200
+    StartDoctypeDecl,
+    EndDoctypeDecl,
+#endif
+#if EXPAT_VERSION == 0x010200
+    ExternalParsedEntityDecl,
+    InternalParsedEntityDecl,
+#endif
+#if EXPAT_VERSION >= 0x015f00
+    EntityDecl,
+    XmlDecl,
+    ElementDecl,
+    AttlistDecl,
+#endif
+    _DummyDecl
+};
+
+
+/* ----------------------------------------------------- */
+
+/* Declarations for objects of type xmlparser */
+
+typedef struct {
+    PyObject_HEAD
+
+    XML_Parser itself;
+    int returns_unicode;        /* True if Unicode strings are returned;
+                                   if false, UTF-8 strings are returned */
+    int ordered_attributes;     /* Return attributes as a list. */
+    int specified_attributes;   /* Report only specified attributes. */
+    int in_callback;            /* Is a callback active? */
+    PyObject **handlers;
+    PyCodeObject **tb_code;
+    PyObject *ErrorObject;
+} xmlparseobject;
+
+#define Xmlparsetype  ((PyTypeObject *) SPyGetGlobalString("Xmlparsetype"))
+
+typedef void (*xmlhandlersetter)(XML_Parser self, void *meth);
+typedef void* xmlhandler;
+
+struct HandlerInfo {
+    const char *name;
+    xmlhandlersetter setter;
+    xmlhandler handler;
+};
+
+extern const struct HandlerInfo handler_info[];
+
+/* Set an integer attribute on the error object; return true on success,
+ * false on an exception.
+ */
+static int
+set_error_attr(PyObject *err, char *name, int value)
+{
+    PyObject *v = PyInt_FromLong(value);
+
+    if (v != NULL && PyObject_SetAttrString(err, name, v) == -1) {
+        Py_DECREF(v);
+        return 0;
+    }
+    return 1;
+}
+
+/* Build and set an Expat exception, including positioning
+ * information.  Always returns NULL.
+ */
+static PyObject *
+set_error(xmlparseobject *self)
+{
+    PyObject *err;
+    char buffer[256];
+    XML_Parser parser = self->itself;
+    int lineno = XML_GetErrorLineNumber(parser);
+    int column = XML_GetErrorColumnNumber(parser);
+    enum XML_Error code = XML_GetErrorCode(parser);
+
+    PyOS_snprintf(buffer, sizeof(buffer), "%.200s: line %i, column %i",
+            XML_ErrorString(code), lineno, column);
+    err = PyObject_CallFunction(self->ErrorObject, "s", buffer);
+    if (  err != NULL
+          && set_error_attr(err, "code", code)
+          && set_error_attr(err, "offset", column)
+          && set_error_attr(err, "lineno", lineno)) {
+        PyErr_SetObject(self->ErrorObject, err);
+    }
+    return NULL;
+}
+
+
+#if EXPAT_VERSION == 0x010200
+/* Convert an array of attributes and their values into a Python dict */
+
+static PyObject *
+conv_atts_using_string(XML_Char **atts)
+{
+    PyObject *attrs_obj = NULL;
+    XML_Char **attrs_p, **attrs_k = NULL;
+    int attrs_len;
+    PyObject *rv;
+
+    if ((attrs_obj = PyDict_New()) == NULL) 
+        goto finally;
+    for (attrs_len = 0, attrs_p = atts; 
+         *attrs_p;
+         attrs_p++, attrs_len++) {
+        if (attrs_len % 2) {
+            rv = PyString_FromString(*attrs_p);  
+            if (!rv) {
+                Py_DECREF(attrs_obj);
+                attrs_obj = NULL;
+                goto finally;
+            }
+            if (PyDict_SetItemString(attrs_obj,
+                                     (char*)*attrs_k, rv) < 0) {
+                Py_DECREF(attrs_obj);
+                attrs_obj = NULL;
+                goto finally;
+            }
+            Py_DECREF(rv);
+        }
+        else 
+            attrs_k = attrs_p;
+    }
+ finally:
+    return attrs_obj;
+}
+#endif
+
+#ifdef Py_USING_UNICODE
+#if EXPAT_VERSION == 0x010200
+static PyObject *
+conv_atts_using_unicode(XML_Char **atts)
+{
+    PyObject *attrs_obj;
+    XML_Char **attrs_p, **attrs_k = NULL;
+    int attrs_len;
+
+    if ((attrs_obj = PyDict_New()) == NULL) 
+        goto finally;
+    for (attrs_len = 0, attrs_p = atts; 
+         *attrs_p;
+         attrs_p++, attrs_len++) {
+        if (attrs_len % 2) {
+            PyObject *attr_str, *value_str;
+            const char *p = (const char *) (*attrs_k);
+            attr_str = PyUnicode_DecodeUTF8(p, strlen(p), "strict"); 
+            if (!attr_str) {
+                Py_DECREF(attrs_obj);
+                attrs_obj = NULL;
+                goto finally;
+            }
+            p = (const char *) *attrs_p;
+            value_str = PyUnicode_DecodeUTF8(p, strlen(p), "strict");
+            if (!value_str) {
+                Py_DECREF(attrs_obj);
+                Py_DECREF(attr_str);
+                attrs_obj = NULL;
+                goto finally;
+            }
+            if (PyDict_SetItem(attrs_obj, attr_str, value_str) < 0) {
+                Py_DECREF(attrs_obj);
+                Py_DECREF(attr_str);
+                Py_DECREF(value_str);
+                attrs_obj = NULL;
+                goto finally;
+            }
+            Py_DECREF(attr_str);
+            Py_DECREF(value_str);
+        }
+        else
+            attrs_k = attrs_p;
+    }
+ finally:
+    return attrs_obj;
+}
+#endif
+
+/* Convert a string of XML_Chars into a Unicode string.
+   Returns None if str is a null pointer. */
+
+static PyObject *
+conv_string_to_unicode(XML_Char *str)
+{
+    /* XXX currently this code assumes that XML_Char is 8-bit, 
+       and hence in UTF-8.  */
+    /* UTF-8 from Expat, Unicode desired */
+    if (str == NULL) {
+        Py_INCREF(Py_None);
+        return Py_None;
+    }
+    return PyUnicode_DecodeUTF8((const char *)str, 
+                                strlen((const char *)str), 
+                                "strict");
+}
+
+static PyObject *
+conv_string_len_to_unicode(const XML_Char *str, int len)
+{
+    /* XXX currently this code assumes that XML_Char is 8-bit, 
+       and hence in UTF-8.  */
+    /* UTF-8 from Expat, Unicode desired */
+    if (str == NULL) {
+        Py_INCREF(Py_None);
+        return Py_None;
+    }
+    return PyUnicode_DecodeUTF8((const char *)str, len, "strict");
+}
+#endif
+
+/* Convert a string of XML_Chars into an 8-bit Python string.
+   Returns None if str is a null pointer. */
+
+static PyObject *
+conv_string_to_utf8(XML_Char *str)
+{
+    /* XXX currently this code assumes that XML_Char is 8-bit, 
+       and hence in UTF-8.  */
+    /* UTF-8 from Expat, UTF-8 desired */
+    if (str == NULL) {
+        Py_INCREF(Py_None);
+        return Py_None;
+    }
+    return PyString_FromString((const char *)str);
+}
+
+static PyObject *
+conv_string_len_to_utf8(const XML_Char *str,  int len) 
+{
+    /* XXX currently this code assumes that XML_Char is 8-bit, 
+       and hence in UTF-8.  */
+    /* UTF-8 from Expat, UTF-8 desired */
+    if (str == NULL) {
+        Py_INCREF(Py_None);
+        return Py_None;
+    }
+    return PyString_FromStringAndSize((const char *)str, len);
+}
+
+/* Callback routines */
+
+static void clear_handlers(xmlparseobject *self, int initial);
+
+static void
+flag_error(xmlparseobject *self)
+{
+    clear_handlers(self, 0);
+}
+
+static PyCodeObject*
+getcode(xmlparseobject *xmlparseobject,
+	enum HandlerTypes slot, char* func_name, int lineno)
+{
+    PyObject *code = NULL;
+    PyObject *name = NULL;
+    PyObject *nulltuple = NULL;
+    PyObject *filename = NULL;
+
+    if (xmlparseobject->tb_code[slot] == NULL) {
+        code = PyString_FromString("");
+        if (code == NULL)
+            goto failed;
+        name = PyString_FromString(func_name);
+        if (name == NULL)
+            goto failed;
+        nulltuple = PyTuple_New(0);
+        if (nulltuple == NULL)
+            goto failed;
+        filename = PyString_FromString(__FILE__);
+        xmlparseobject->tb_code[slot] =
+            PyCode_New(0,		/* argcount */
+                       0,		/* nlocals */
+                       0,		/* stacksize */
+                       0,		/* flags */
+                       code,		/* code */
+                       nulltuple,	/* consts */
+                       nulltuple,	/* names */
+                       nulltuple,	/* varnames */
+#if PYTHON_API_VERSION >= 1010
+                       nulltuple,	/* freevars */
+                       nulltuple,	/* cellvars */
+#endif
+                       filename,	/* filename */
+                       name,		/* name */
+                       lineno,		/* firstlineno */
+                       code		/* lnotab */
+                       );
+        if (xmlparseobject->tb_code[slot] == NULL)
+            goto failed;
+        Py_DECREF(code);
+        Py_DECREF(nulltuple);
+        Py_DECREF(filename);
+        Py_DECREF(name);
+    }
+    return xmlparseobject->tb_code[slot];
+ failed:
+    Py_XDECREF(code);
+    Py_XDECREF(name);
+    return NULL;
+}
+
+static int
+trace_frame(PyThreadState *tstate, PyFrameObject *f, int code, PyObject *val)
+{
+    int result = 0;
+    if (!tstate->use_tracing || tstate->tracing)
+	return 0;
+    if (tstate->c_profilefunc != NULL) {
+	tstate->tracing++;
+	result = tstate->c_profilefunc(tstate->c_profileobj,
+				       f, code , val);
+	tstate->use_tracing = ((tstate->c_tracefunc != NULL)
+			       || (tstate->c_profilefunc != NULL));
+	tstate->tracing--;
+	if (result)
+	    return result;
+    }
+    if (tstate->c_tracefunc != NULL) {
+	tstate->tracing++;
+	result = tstate->c_tracefunc(tstate->c_traceobj,
+				     f, code , val);
+	tstate->use_tracing = ((tstate->c_tracefunc != NULL)
+			       || (tstate->c_profilefunc != NULL));
+	tstate->tracing--;
+    }	
+    return result;
+}
+
+static PyObject*
+call_with_frame(PyCodeObject *c, PyObject* func, PyObject* args)
+{
+    PyThreadState *tstate = PyThreadState_GET();
+    PyFrameObject *f;
+    PyObject *res;
+
+    if (c == NULL)
+        return NULL;
+    
+    f = PyFrame_New(
+                    tstate,			/*back*/
+                    c,				/*code*/
+                    PyEval_GetGlobals(),	/*globals*/
+                    NULL			/*locals*/
+                    );
+    if (f == NULL)
+        return NULL;
+    tstate->frame = f;
+    if (trace_frame(tstate, f, PyTrace_CALL, Py_None)) {
+	Py_DECREF(f);
+	return NULL;
+    }
+    res = PyEval_CallObject(func, args);
+    if (res == NULL && tstate->curexc_traceback == NULL)
+        PyTraceBack_Here(f);
+    else {
+	if (trace_frame(tstate, f, PyTrace_RETURN, res)) {
+	    Py_XDECREF(res);
+	    res = NULL;
+	}
+    }
+    tstate->frame = f->f_back;
+    Py_DECREF(f);
+    return res;
+}
+
+#ifndef Py_USING_UNICODE
+#define STRING_CONV_FUNC conv_string_to_utf8
+#else
+/* Python 1.6 and later versions */
+#define STRING_CONV_FUNC (self->returns_unicode \
+                          ? conv_string_to_unicode : conv_string_to_utf8)
+#endif
+
+static void
+my_StartElementHandler(void *userData,
+                       const XML_Char *name, const XML_Char **atts)
+{
+    xmlparseobject *self = (xmlparseobject *)userData;
+
+    if (self->handlers[StartElement]
+        && self->handlers[StartElement] != Py_None) {
+        PyObject *container, *rv, *args;
+        int i, max;
+
+        /* Set max to the number of slots filled in atts[]; max/2 is
+         * the number of attributes we need to process.
+         */
+        if (self->specified_attributes) {
+            max = XML_GetSpecifiedAttributeCount(self->itself);
+        }
+        else {
+            max = 0;
+            while (atts[max] != NULL)
+                max += 2;
+        }
+        /* Build the container. */
+        if (self->ordered_attributes)
+            container = PyList_New(max);
+        else
+            container = PyDict_New();
+        if (container == NULL) {
+            flag_error(self);
+            return;
+        }
+        for (i = 0; i < max; i += 2) {
+            PyObject *n = STRING_CONV_FUNC((XML_Char *) atts[i]);
+            PyObject *v;
+            if (n == NULL) {
+                flag_error(self);
+                Py_DECREF(container);
+                return;
+            }
+            v = STRING_CONV_FUNC((XML_Char *) atts[i+1]);
+            if (v == NULL) {
+                flag_error(self);
+                Py_DECREF(container);
+                Py_DECREF(n);
+                return;
+            }
+            if (self->ordered_attributes) {
+                PyList_SET_ITEM(container, i, n);
+                PyList_SET_ITEM(container, i+1, v);
+            }
+            else if (PyDict_SetItem(container, n, v)) {
+                flag_error(self);
+                Py_DECREF(n);
+                Py_DECREF(v);
+                return;
+            }
+            else {
+                Py_DECREF(n);
+                Py_DECREF(v);
+            }
+        }
+        args = Py_BuildValue("(O&N)", STRING_CONV_FUNC,name, container);
+        if (args == NULL) {
+            Py_DECREF(container);
+            return;
+        }
+        /* Container is now a borrowed reference; ignore it. */
+        self->in_callback = 1;
+        rv = call_with_frame(getcode(self, 
+				     StartElement, "StartElement", __LINE__),
+                             self->handlers[StartElement], args);
+        self->in_callback = 0;
+        Py_DECREF(args);
+        if (rv == NULL) {
+            flag_error(self);
+            return;
+        }
+        Py_DECREF(rv);
+    }
+}
+
+#define RC_HANDLER(RC, NAME, PARAMS, INIT, PARAM_FORMAT, CONVERSION, \
+                RETURN, GETUSERDATA) \
+static RC \
+my_##NAME##Handler PARAMS {\
+    xmlparseobject *self = GETUSERDATA ; \
+    PyObject *args = NULL; \
+    PyObject *rv = NULL; \
+    INIT \
+\
+    if (self->handlers[NAME] \
+        && self->handlers[NAME] != Py_None) { \
+        args = Py_BuildValue PARAM_FORMAT ;\
+        if (!args) { flag_error(self); return RETURN;} \
+        self->in_callback = 1; \
+        rv = call_with_frame(getcode(self,NAME,#NAME,__LINE__), \
+                             self->handlers[NAME], args); \
+        self->in_callback = 0; \
+        Py_DECREF(args); \
+        if (rv == NULL) { \
+            flag_error(self); \
+            return RETURN; \
+        } \
+        CONVERSION \
+        Py_DECREF(rv); \
+    } \
+    return RETURN; \
+}
+
+#define VOID_HANDLER(NAME, PARAMS, PARAM_FORMAT) \
+	RC_HANDLER(void, NAME, PARAMS, ;, PARAM_FORMAT, ;, ;,\
+	(xmlparseobject *)userData)
+
+#define INT_HANDLER(NAME, PARAMS, PARAM_FORMAT)\
+	RC_HANDLER(int, NAME, PARAMS, int rc=0;, PARAM_FORMAT, \
+			rc = PyInt_AsLong(rv);, rc, \
+	(xmlparseobject *)userData)
+
+VOID_HANDLER(EndElement, 
+             (void *userData, const XML_Char *name), 
+             ("(O&)", STRING_CONV_FUNC, name))
+
+VOID_HANDLER(ProcessingInstruction,
+             (void *userData, 
+              const XML_Char *target, 
+              const XML_Char *data),
+             ("(O&O&)",STRING_CONV_FUNC,target, STRING_CONV_FUNC,data))
+
+#ifndef Py_USING_UNICODE
+VOID_HANDLER(CharacterData, 
+             (void *userData, const XML_Char *data, int len), 
+             ("(N)", conv_string_len_to_utf8(data,len)))
+#else
+VOID_HANDLER(CharacterData, 
+             (void *userData, const XML_Char *data, int len), 
+             ("(N)", (self->returns_unicode 
+                      ? conv_string_len_to_unicode(data,len) 
+                      : conv_string_len_to_utf8(data,len))))
+#endif
+
+VOID_HANDLER(UnparsedEntityDecl,
+             (void *userData, 
+              const XML_Char *entityName,
+              const XML_Char *base,
+              const XML_Char *systemId,
+              const XML_Char *publicId,
+              const XML_Char *notationName),
+             ("(O&O&O&O&O&)", 
+              STRING_CONV_FUNC,entityName, STRING_CONV_FUNC,base, 
+              STRING_CONV_FUNC,systemId, STRING_CONV_FUNC,publicId, 
+              STRING_CONV_FUNC,notationName))
+
+#if EXPAT_VERSION >= 0x015f00
+#ifndef Py_USING_UNICODE
+VOID_HANDLER(EntityDecl,
+             (void *userData,
+              const XML_Char *entityName,
+              int is_parameter_entity,
+              const XML_Char *value,
+              int value_length,
+              const XML_Char *base,
+              const XML_Char *systemId,
+              const XML_Char *publicId,
+              const XML_Char *notationName),
+             ("O&iNO&O&O&O&",
+              STRING_CONV_FUNC,entityName, is_parameter_entity,
+              conv_string_len_to_utf8(value, value_length),
+              STRING_CONV_FUNC,base, STRING_CONV_FUNC,systemId,
+              STRING_CONV_FUNC,publicId, STRING_CONV_FUNC,notationName))
+#else
+VOID_HANDLER(EntityDecl,
+             (void *userData,
+              const XML_Char *entityName,
+              int is_parameter_entity,
+              const XML_Char *value,
+              int value_length,
+              const XML_Char *base,
+              const XML_Char *systemId,
+              const XML_Char *publicId,
+              const XML_Char *notationName),
+             ("O&iNO&O&O&O&",
+              STRING_CONV_FUNC,entityName, is_parameter_entity,
+              (self->returns_unicode 
+               ? conv_string_len_to_unicode(value, value_length) 
+               : conv_string_len_to_utf8(value, value_length)),
+              STRING_CONV_FUNC,base, STRING_CONV_FUNC,systemId,
+              STRING_CONV_FUNC,publicId, STRING_CONV_FUNC,notationName))
+#endif
+
+VOID_HANDLER(XmlDecl,
+             (void *userData,
+              const XML_Char *version,
+              const XML_Char *encoding,
+              int standalone),
+             ("(O&O&i)",
+              STRING_CONV_FUNC,version, STRING_CONV_FUNC,encoding, 
+              standalone))
+
+static PyObject *
+conv_content_model(XML_Content * const model,
+                   PyObject *(*conv_string)(XML_Char *))
+{
+    PyObject *result = NULL;
+    PyObject *children = PyTuple_New(model->numchildren);
+    int i;
+
+    if (children != NULL) {
+        assert(model->numchildren < INT_MAX);
+        for (i = 0; i < (int)model->numchildren; ++i) {
+            PyObject *child = conv_content_model(&model->children[i],
+                                                 conv_string);
+            if (child == NULL) {
+                Py_XDECREF(children);
+                return NULL;
+            }
+            PyTuple_SET_ITEM(children, i, child);
+        }
+        result = Py_BuildValue("(iiO&N)",
+                               model->type, model->quant,
+                               conv_string,model->name, children);
+    }
+    return result;
+}
+
+static void
+my_ElementDeclHandler(void *userData,
+                      const XML_Char *name,
+                      XML_Content *model)
+{
+    xmlparseobject *self = (xmlparseobject *)userData;
+    PyObject *args = NULL;
+
+    if (self->handlers[ElementDecl] != NULL
+        && self->handlers[ElementDecl] != Py_None) {
+        PyObject *rv = NULL;
+        PyObject *modelobj, *nameobj;
+
+#ifdef Py_USING_UNICODE
+        modelobj = conv_content_model(model,
+                                      (self->returns_unicode
+                                       ? conv_string_to_unicode
+                                       : conv_string_to_utf8));
+#else
+        modelobj = conv_content_model(model, conv_string_to_utf8);
+#endif
+        if (modelobj == NULL) {
+            flag_error(self);
+            goto finally;
+        }
+        nameobj = PyString_FromString(name);
+        if (nameobj == NULL) {
+            Py_DECREF(modelobj);
+            flag_error(self);
+            goto finally;
+        }
+        args = Py_BuildValue("NN", nameobj, modelobj);
+        if (args == NULL) {
+            Py_DECREF(modelobj);
+            flag_error(self);
+            goto finally;
+        }
+        self->in_callback = 1;
+        rv = call_with_frame(getcode(self,
+				     ElementDecl, "ElementDecl", __LINE__),
+                             self->handlers[ElementDecl], args);
+        self->in_callback = 0;
+        if (rv == NULL) {
+            flag_error(self);
+            goto finally;
+        }
+        Py_DECREF(rv);
+    }
+ finally:
+    Py_XDECREF(args);
+    /* XML_FreeContentModel() was introduced in Expat 1.95.6. */
+#if EXPAT_VERSION >= 0x015f06
+    XML_FreeContentModel(self->itself, model);
+#else
+    free(model);
+#endif
+    return;
+}
+
+VOID_HANDLER(AttlistDecl,
+             (void *userData,
+              const XML_Char *elname,
+              const XML_Char *attname,
+              const XML_Char *att_type,
+              const XML_Char *dflt,
+              int isrequired),
+             ("(O&O&O&O&i)",
+              STRING_CONV_FUNC,elname, STRING_CONV_FUNC,attname,
+              STRING_CONV_FUNC,att_type, STRING_CONV_FUNC,dflt,
+              isrequired))
+#endif
+
+VOID_HANDLER(NotationDecl, 
+		(void *userData,
+			const XML_Char *notationName,
+			const XML_Char *base,
+			const XML_Char *systemId,
+			const XML_Char *publicId),
+                ("(O&O&O&O&)", 
+		 STRING_CONV_FUNC,notationName, STRING_CONV_FUNC,base, 
+		 STRING_CONV_FUNC,systemId, STRING_CONV_FUNC,publicId))
+
+VOID_HANDLER(StartNamespaceDecl,
+		(void *userData,
+		      const XML_Char *prefix,
+		      const XML_Char *uri),
+                ("(O&O&)", STRING_CONV_FUNC,prefix, STRING_CONV_FUNC,uri))
+
+VOID_HANDLER(EndNamespaceDecl,
+		(void *userData,
+		    const XML_Char *prefix),
+                ("(O&)", STRING_CONV_FUNC,prefix))
+
+VOID_HANDLER(Comment,
+               (void *userData, const XML_Char *prefix),
+                ("(O&)", STRING_CONV_FUNC,prefix))
+
+VOID_HANDLER(StartCdataSection,
+               (void *userData),
+		("()"))
+		
+VOID_HANDLER(EndCdataSection,
+               (void *userData),
+		("()"))
+
+#ifndef Py_USING_UNICODE
+VOID_HANDLER(Default,
+	      (void *userData,  const XML_Char *s, int len),
+	      ("(N)", conv_string_len_to_utf8(s,len)))
+
+VOID_HANDLER(DefaultHandlerExpand,
+	      (void *userData,  const XML_Char *s, int len),
+	      ("(N)", conv_string_len_to_utf8(s,len)))
+#else
+VOID_HANDLER(Default,
+	      (void *userData,  const XML_Char *s, int len),
+	      ("(N)", (self->returns_unicode 
+		       ? conv_string_len_to_unicode(s,len) 
+		       : conv_string_len_to_utf8(s,len))))
+
+VOID_HANDLER(DefaultHandlerExpand,
+	      (void *userData,  const XML_Char *s, int len),
+	      ("(N)", (self->returns_unicode 
+		       ? conv_string_len_to_unicode(s,len) 
+		       : conv_string_len_to_utf8(s,len))))
+#endif
+
+INT_HANDLER(NotStandalone, 
+		(void *userData), 
+		("()"))
+
+RC_HANDLER(int, ExternalEntityRef,
+		(XML_Parser parser,
+		    const XML_Char *context,
+		    const XML_Char *base,
+		    const XML_Char *systemId,
+		    const XML_Char *publicId),
+		int rc=0;,
+                ("(O&O&O&O&)", 
+		 STRING_CONV_FUNC,context, STRING_CONV_FUNC,base, 
+		 STRING_CONV_FUNC,systemId, STRING_CONV_FUNC,publicId),
+		rc = PyInt_AsLong(rv);, rc,
+	   (xmlparseobject *) XML_GetUserData(parser))
+
+/* XXX UnknownEncodingHandler */
+
+#if EXPAT_VERSION == 0x010200
+VOID_HANDLER(StartDoctypeDecl,
+	     (void *userData, const XML_Char *doctypeName),
+	     ("(O&OOi)", STRING_CONV_FUNC,doctypeName,
+              Py_None, Py_None, -1))
+#elif EXPAT_VERSION >= 0x015f00
+VOID_HANDLER(StartDoctypeDecl,
+             (void *userData, const XML_Char *doctypeName,
+              const XML_Char *sysid, const XML_Char *pubid,
+              int has_internal_subset),
+             ("(O&O&O&i)", STRING_CONV_FUNC,doctypeName,
+              STRING_CONV_FUNC,sysid, STRING_CONV_FUNC,pubid,
+              has_internal_subset))
+#endif
+
+#if EXPAT_VERSION >= 0x010200
+VOID_HANDLER(EndDoctypeDecl, (void *userData), ("()"))
+#endif
+
+#if EXPAT_VERSION == 0x010200
+VOID_HANDLER(ExternalParsedEntityDecl,
+	     (void *userData, const XML_Char *entityName,
+	      const XML_Char *base, const XML_Char *systemId,
+	      const XML_Char *publicId),
+	     ("(O&O&O&O&)", STRING_CONV_FUNC, entityName,
+	      STRING_CONV_FUNC, base, STRING_CONV_FUNC, systemId,
+	      STRING_CONV_FUNC, publicId))
+
+VOID_HANDLER(InternalParsedEntityDecl,
+	     (void *userData, const XML_Char *entityName,
+	      const XML_Char *replacementText, int replacementTextLength),
+	     ("(O&O&i)", STRING_CONV_FUNC, entityName,
+	      STRING_CONV_FUNC, replacementText, replacementTextLength))
+
+#endif /* Expat version 1.2 & better */
+
+/* ---------------------------------------------------------------- */
+
+static PyObject *
+xmlparse_Parse(xmlparseobject *self, PyObject *args)
+{
+    char *s;
+    int slen;
+    int isFinal = 0;
+    int rv;
+
+    if (!PyArg_ParseTuple(args, "s#|i:Parse", &s, &slen, &isFinal))
+        return NULL;
+    rv = XML_Parse(self->itself, s, slen, isFinal);
+    if (PyErr_Occurred()) {	
+        return NULL;
+    }
+    else if (rv == 0) {
+        return set_error(self);
+    }
+    return PyInt_FromLong(rv);
+}
+
+/* File reading copied from cPickle */
+
+#define BUF_SIZE 2048
+
+static int
+readinst(char *buf, int buf_size, PyObject *meth)
+{
+    PyObject *arg = NULL;
+    PyObject *bytes = NULL;
+    PyObject *str = NULL;
+    int len = -1;
+
+    if ((bytes = PyInt_FromLong(buf_size)) == NULL)
+        goto finally;
+
+    if ((arg = PyTuple_New(1)) == NULL)
+        goto finally;
+
+    PyTuple_SET_ITEM(arg, 0, bytes);
+
+    if ((str = PyObject_CallObject(meth, arg)) == NULL)
+        goto finally;
+
+    /* XXX what to do if it returns a Unicode string? */
+    if (!PyString_Check(str)) {
+        PyErr_Format(PyExc_TypeError, 
+                     "read() did not return a string object (type=%.400s)",
+                     str->ob_type->tp_name);
+        goto finally;
+    }
+    len = PyString_GET_SIZE(str);
+    if (len > buf_size) {
+        PyErr_Format(PyExc_ValueError,
+                     "read() returned too much data: "
+                     "%i bytes requested, %i returned",
+                     buf_size, len);
+        Py_DECREF(str);
+        goto finally;
+    }
+    memcpy(buf, PyString_AsString(str), len);
+finally:
+    Py_XDECREF(arg);
+    Py_XDECREF(str);
+    return len;
+}
+
+static PyObject *
+xmlparse_ParseFile(xmlparseobject *self, PyObject *args)
+{
+    int rv = 1;
+    PyObject *f;
+    FILE *fp;
+    PyObject *readmethod = NULL;
+
+    if (!PyArg_ParseTuple(args, "O:ParseFile", &f))
+        return NULL;
+
+    if (PyFile_Check(f)) {
+        fp = PyFile_AsFile(f);
+    }
+    else{
+        fp = NULL;
+        readmethod = PyObject_GetAttrString(f, "read");
+        if (readmethod == NULL) {
+            PyErr_Clear();
+            PyErr_SetString(PyExc_TypeError, 
+                            "argument must have 'read' attribute");
+            return 0;
+        }
+    }
+    for (;;) {
+        int bytes_read;
+        void *buf = XML_GetBuffer(self->itself, BUF_SIZE);
+        if (buf == NULL)
+            return PyErr_NoMemory();
+
+        if (fp) {
+            bytes_read = fread(buf, sizeof(char), BUF_SIZE, fp);
+            if (bytes_read < 0) {
+                PyErr_SetFromErrno(PyExc_IOError);
+                return NULL;
+            }
+        }
+        else {
+            bytes_read = readinst((char *) buf, BUF_SIZE, readmethod);
+            if (bytes_read < 0)
+                return NULL;
+        }
+        rv = XML_ParseBuffer(self->itself, bytes_read, bytes_read == 0);
+        if (PyErr_Occurred())
+            return NULL;
+
+        if (!rv || bytes_read == 0)
+            break;
+    }
+    if (rv == 0) {
+        return set_error(self);
+    }
+    return Py_BuildValue("i", rv);
+}
+
+static PyObject *
+xmlparse_SetBase(xmlparseobject *self, PyObject *args)
+{
+    char *base;
+
+    if (!PyArg_ParseTuple(args, "s:SetBase", &base))
+        return NULL;
+    if (!XML_SetBase(self->itself, base)) {
+	return PyErr_NoMemory();
+    }
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+static PyObject *
+xmlparse_GetBase(xmlparseobject *self, PyObject *args)
+{
+    if (!PyArg_ParseTuple(args, ":GetBase"))
+        return NULL;
+
+    return Py_BuildValue("z", XML_GetBase(self->itself));
+}
+
+#if EXPAT_VERSION >= 0x015f00
+
+static PyObject *
+xmlparse_GetInputContext(xmlparseobject *self, PyObject *args)
+{
+    PyObject *result = NULL;
+
+    if (PyArg_ParseTuple(args, ":GetInputContext")) {
+        if (self->in_callback) {
+            int offset, size;
+            const char *buffer
+                = XML_GetInputContext(self->itself, &offset, &size);
+
+            if (buffer != NULL)
+                result = PyString_FromStringAndSize(buffer + offset, size);
+            else {
+                result = Py_None;
+                Py_INCREF(result);
+            }
+        }
+        else {
+            result = Py_None;
+            Py_INCREF(result);
+        }
+    }
+    return result;
+}
+#endif
+
+static PyObject *
+xmlparse_ExternalEntityParserCreate(xmlparseobject *self, PyObject *args)
+{
+    char *context;
+    char *encoding = NULL;
+    xmlparseobject *new_parser;
+    int i;
+
+    if (!PyArg_ParseTuple(args, "z|s:ExternalEntityParserCreate",
+                          &context, &encoding)) {
+        return NULL;
+    }
+
+#if PY_MAJOR_VERSION == 1 && PY_MINOR_VERSION < 6
+    new_parser = PyObject_NEW(xmlparseobject, Xmlparsetype);
+#else
+#ifndef Py_TPFLAGS_HAVE_GC
+    /* Python versions 1.6 to 2.1 */
+    new_parser = PyObject_New(xmlparseobject, Xmlparsetype);
+#else
+    /* Python versions 2.2 and later */
+    new_parser = PyObject_GC_New(xmlparseobject, Xmlparsetype);
+#endif
+#endif
+
+    if (new_parser == NULL)
+        return NULL;
+    new_parser->returns_unicode = self->returns_unicode;
+    new_parser->ordered_attributes = self->ordered_attributes;
+    new_parser->specified_attributes = self->specified_attributes;
+    new_parser->in_callback = 0;
+    new_parser->itself = XML_ExternalEntityParserCreate(self->itself, context,
+							encoding);
+    new_parser->handlers = 0;
+    new_parser->tb_code = 0;
+#ifdef Py_TPFLAGS_HAVE_GC
+    PyObject_GC_Track(new_parser);
+#else
+    PyObject_GC_Init(new_parser);
+#endif
+
+    if (!new_parser->itself) {
+        Py_DECREF(new_parser);
+        return PyErr_NoMemory();
+    }
+
+    XML_SetUserData(new_parser->itself, (void *)new_parser);
+
+    /* allocate and clear handlers first */
+    for(i = 0; handler_info[i].name != NULL; i++)
+        /* do nothing */;
+
+    new_parser->handlers = (PyObject **) malloc(sizeof(PyObject *)*i);
+    if (!new_parser->handlers) {
+        Py_DECREF(new_parser);
+        return PyErr_NoMemory();
+    }
+
+    new_parser->tb_code = (PyCodeObject **) calloc(i, sizeof(PyCodeObject *));
+    if (!new_parser->tb_code) {
+      free(new_parser->handlers);
+      new_parser->handlers = NULL;
+      Py_DECREF(new_parser);
+      return PyErr_NoMemory();
+    }
+
+    clear_handlers(new_parser, 1);
+
+    /* then copy handlers from self */
+    for (i = 0; handler_info[i].name != NULL; i++) {
+        if (self->handlers[i]) {
+            Py_INCREF(self->handlers[i]);
+            new_parser->handlers[i] = self->handlers[i];
+            handler_info[i].setter(new_parser->itself, 
+                                   handler_info[i].handler);
+        }
+    }
+    return (PyObject *)new_parser;    
+}
+
+#if EXPAT_VERSION >= 0x010200
+
+static PyObject*
+xmlparse_SetParamEntityParsing(xmlparseobject *p, PyObject* args)
+{
+    int flag;
+    if (!PyArg_ParseTuple(args, "i", &flag))
+        return NULL;
+    flag = (int) XML_SetParamEntityParsing(p->itself, 
+					   (enum XML_ParamEntityParsing) flag);
+    return PyInt_FromLong(flag);
+}
+
+#endif /* Expat version 1.2 or better */
+
+static const struct PyMethodDef xmlparse_methods[] = {
+    {"Parse",	  (PyCFunction)xmlparse_Parse,
+     METH_VARARGS,	0 /* xmlparse_Parse__doc__ */},
+    {"ParseFile", (PyCFunction)xmlparse_ParseFile,
+     METH_VARARGS,	0 /* xmlparse_ParseFile__doc__ */},
+    {"SetBase",   (PyCFunction)xmlparse_SetBase,
+     METH_VARARGS, 0 /* xmlparse_SetBase__doc__ */},
+    {"GetBase",   (PyCFunction)xmlparse_GetBase,
+     METH_VARARGS, 0 /* xmlparse_GetBase__doc__ */},
+    {"ExternalEntityParserCreate", (PyCFunction)xmlparse_ExternalEntityParserCreate,
+     METH_VARARGS, 0 /* xmlparse_ExternalEntityParserCreate__doc__ */},
+#if EXPAT_VERSION >= 0x010200
+    {"SetParamEntityParsing", (PyCFunction)xmlparse_SetParamEntityParsing,
+     METH_VARARGS, 0 /* xmlparse_SetParamEntityParsing__doc__ */},
+#endif
+#if EXPAT_VERSION >= 0x015f00
+    {"GetInputContext", (PyCFunction)xmlparse_GetInputContext,
+     METH_VARARGS, 0 /* xmlparse_GetInputContext__doc__ */},
+#endif
+	{NULL,		NULL}		/* sentinel */
+};
+
+/* ---------- */
+
+
+#ifdef Py_USING_UNICODE
+
+/* 
+    pyexpat international encoding support.
+    Make it as simple as possible.
+*/
+
+static const char template_buffer[] = {
+  '\x00', '\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07',
+  '\x08', '\x09', '\x0A', '\x0B', '\x0C', '\x0D', '\x0E', '\x0F',
+  '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
+  '\x18', '\x19', '\x1A', '\x1B', '\x1C', '\x1D', '\x1E', '\x1F',
+  '\x20', '\x21', '\x22', '\x23', '\x24', '\x25', '\x26', '\x27',
+  '\x28', '\x29', '\x2A', '\x2B', '\x2C', '\x2D', '\x2E', '\x2F',
+  '\x30', '\x31', '\x32', '\x33', '\x34', '\x35', '\x36', '\x37',
+  '\x38', '\x39', '\x3A', '\x3B', '\x3C', '\x3D', '\x3E', '\x3F',
+  '\x40', '\x41', '\x42', '\x43', '\x44', '\x45', '\x46', '\x47',
+  '\x48', '\x49', '\x4A', '\x4B', '\x4C', '\x4D', '\x4E', '\x4F',
+  '\x50', '\x51', '\x52', '\x53', '\x54', '\x55', '\x56', '\x57',
+  '\x58', '\x59', '\x5A', '\x5B', '\x5C', '\x5D', '\x5E', '\x5F',
+  '\x60', '\x61', '\x62', '\x63', '\x64', '\x65', '\x66', '\x67',
+  '\x68', '\x69', '\x6A', '\x6B', '\x6C', '\x6D', '\x6E', '\x6F',
+  '\x70', '\x71', '\x72', '\x73', '\x74', '\x75', '\x76', '\x77',
+  '\x78', '\x79', '\x7A', '\x7B', '\x7C', '\x7D', '\x7E', '\x7F',
+  '\x80', '\x81', '\x82', '\x83', '\x84', '\x85', '\x86', '\x87',
+  '\x88', '\x89', '\x8A', '\x8B', '\x8C', '\x8D', '\x8E', '\x8F',
+  '\x90', '\x91', '\x92', '\x93', '\x94', '\x95', '\x96', '\x97',
+  '\x98', '\x99', '\x9A', '\x9B', '\x9C', '\x9D', '\x9E', '\x9F',
+  '\xA0', '\xA1', '\xA2', '\xA3', '\xA4', '\xA5', '\xA6', '\xA7',
+  '\xA8', '\xA9', '\xAA', '\xAB', '\xAC', '\xAD', '\xAE', '\xAF',
+  '\xB0', '\xB1', '\xB2', '\xB3', '\xB4', '\xB5', '\xB6', '\xB7',
+  '\xB8', '\xB9', '\xBA', '\xBB', '\xBC', '\xBD', '\xBE', '\xBF',
+  '\xC0', '\xC1', '\xC2', '\xC3', '\xC4', '\xC5', '\xC6', '\xC7',
+  '\xC8', '\xC9', '\xCA', '\xCB', '\xCC', '\xCD', '\xCE', '\xCF',
+  '\xD0', '\xD1', '\xD2', '\xD3', '\xD4', '\xD5', '\xD6', '\xD7',
+  '\xD8', '\xD9', '\xDA', '\xDB', '\xDC', '\xDD', '\xDE', '\xDF',
+  '\xE0', '\xE1', '\xE2', '\xE3', '\xE4', '\xE5', '\xE6', '\xE7',
+  '\xE8', '\xE9', '\xEA', '\xEB', '\xEC', '\xED', '\xEE', '\xEF',
+  '\xF0', '\xF1', '\xF2', '\xF3', '\xF4', '\xF5', '\xF6', '\xF7',
+  '\xF8', '\xF9', '\xFA', '\xFB', '\xFC', '\xFD', '\xFE', '\xFF', 
+  '\x00'
+};
+
+
+int 
+PyUnknownEncodingHandler(void * /*encodingHandlerData*/, 
+const XML_Char *name, 
+XML_Encoding * info)
+{
+    PyUnicodeObject *_u_string = NULL;
+    int result = 0;
+    int i;
+    
+    /* Yes, supports only 8bit encodings */
+    _u_string = (PyUnicodeObject *)
+        PyUnicode_Decode(template_buffer, 256, name, "replace");
+    
+    if (_u_string == NULL)
+	return result;
+    
+    for (i = 0; i < 256; i++) {
+	/* Stupid to access directly, but fast */
+	Py_UNICODE c = _u_string->str[i];
+	if (c == Py_UNICODE_REPLACEMENT_CHARACTER)
+	    info->map[i] = -1;
+	else
+	    info->map[i] = c;
+    }
+    
+    info->data = NULL;
+    info->convert = NULL;
+    info->release = NULL;
+    result=1;
+    
+    Py_DECREF(_u_string);
+    return result;
+}
+
+#endif
+
+static PyObject *
+// XXX could be removed
+newxmlparseobject(PyObject* /*module*/, char *encoding, 
+		  char *namespace_separator)
+{
+    int i;
+    xmlparseobject *self;
+
+#if PY_MAJOR_VERSION == 1 && PY_MINOR_VERSION < 6
+    self = PyObject_NEW(xmlparseobject, Xmlparsetype);
+    if (self == NULL)
+        return NULL;
+
+    self->returns_unicode = 0;
+#else
+    /* Code for versions 1.6 and later */
+#ifdef Py_TPFLAGS_HAVE_GC
+    /* Code for versions 2.2 and later */
+    self = PyObject_GC_New(xmlparseobject, Xmlparsetype);
+#else
+    self = PyObject_New(xmlparseobject, Xmlparsetype);
+#endif
+    if (self == NULL)
+        return NULL;
+
+    self->returns_unicode = 1;
+#endif
+    self->ErrorObject = //PyObject_GetAttrString(module, "error");
+	SPyGetGlobalString("pyexpaterror");
+    self->ordered_attributes = 0;
+    self->specified_attributes = 0;
+    self->in_callback = 0;
+    self->handlers = NULL;
+    self->tb_code = NULL;
+    if (namespace_separator != NULL) {
+        self->itself = XML_ParserCreateNS(encoding, *namespace_separator);
+    }
+    else {
+        self->itself = XML_ParserCreate(encoding);
+    }
+#ifdef Py_TPFLAGS_HAVE_GC
+    PyObject_GC_Track(self);
+#else
+    PyObject_GC_Init(self);
+#endif
+    if (self->itself == NULL) {
+        PyErr_SetString(PyExc_RuntimeError, 
+                        "XML_ParserCreate failed");
+        Py_DECREF(self);
+        return NULL;
+    }
+    XML_SetUserData(self->itself, (void *)self);
+#ifdef Py_USING_UNICODE
+    XML_SetUnknownEncodingHandler(self->itself, (XML_UnknownEncodingHandler) PyUnknownEncodingHandler, NULL);
+#endif
+
+    for(i = 0; handler_info[i].name != NULL; i++)
+        /* do nothing */;
+
+    self->handlers = (PyObject **) malloc(sizeof(PyObject *)*i);
+    if (!self->handlers){
+      Py_DECREF(self);
+      return PyErr_NoMemory();
+    }
+
+    self->tb_code = (PyCodeObject **) calloc(i, sizeof(PyCodeObject *));
+    if (!self->tb_code){
+      free(self->handlers);
+      self->handlers = NULL;
+      Py_DECREF(self);
+      return PyErr_NoMemory();
+    }
+
+    clear_handlers(self, 1);
+
+    return (PyObject*)self;
+}
+
+
+static void
+xmlparse_dealloc(xmlparseobject *self)
+{
+    int i;
+#ifdef Py_TPFLAGS_HAVE_GC
+    PyObject_GC_UnTrack(self);
+#else
+    PyObject_GC_Fini(self);
+#endif
+    if (self->itself != NULL)
+        XML_ParserFree(self->itself);
+    self->itself = NULL;
+
+    if (self->handlers != NULL) {
+        PyObject *temp;
+        for (i = 0; handler_info[i].name != NULL; i++) {
+            temp = self->handlers[i];
+            self->handlers[i] = NULL;
+            Py_XDECREF(temp);
+        }
+        free(self->handlers);
+	self->handlers = NULL;
+    }
+    if (self->tb_code) {
+      for (i = 0; handler_info[i].name; i++) {
+	PyCodeObject *temp;
+	if ((temp = self->tb_code[i]) != NULL) {
+	  self->tb_code[i] = NULL;
+	  Py_XDECREF(temp);
+	}
+      }
+      free(self->tb_code);
+      self->tb_code = NULL;
+    }
+#if PY_MAJOR_VERSION == 1 && PY_MINOR_VERSION < 6
+    /* Code for versions before 1.6 */
+    free(self);
+#else
+#ifndef Py_TPFLAGS_HAVE_GC
+    /* Code for versions 1.6 to 2.1 */
+    PyObject_Del(self);
+#else
+    /* Code for versions 2.2 and later. */
+    PyObject_GC_Del(self);
+#endif
+#endif
+}
+
+static int
+handlername2int(const char *name)
+{
+    int i;
+    for (i=0; handler_info[i].name != NULL; i++) {
+        if (strcmp(name, handler_info[i].name) == 0) {
+            return i;
+        }
+    }
+    return -1;
+}
+
+static PyObject *
+xmlparse_getattr(xmlparseobject *self, char *name)
+{
+    int handlernum;
+    if (strcmp(name, "ErrorCode") == 0)
+        return PyInt_FromLong((long) XML_GetErrorCode(self->itself));
+    if (strcmp(name, "ErrorLineNumber") == 0)
+        return PyInt_FromLong((long) XML_GetErrorLineNumber(self->itself));
+    if (strcmp(name, "ErrorColumnNumber") == 0)
+        return PyInt_FromLong((long) XML_GetErrorColumnNumber(self->itself));
+    if (strcmp(name, "ErrorByteIndex") == 0)
+        return PyInt_FromLong((long) XML_GetErrorByteIndex(self->itself));
+    if (strcmp(name, "ordered_attributes") == 0)
+        return PyInt_FromLong((long) self->ordered_attributes);
+    if (strcmp(name, "returns_unicode") == 0)
+        return PyInt_FromLong((long) self->returns_unicode);
+    if (strcmp(name, "specified_attributes") == 0)
+        return PyInt_FromLong((long) self->specified_attributes);
+
+    handlernum = handlername2int(name);
+
+    if (handlernum != -1 && self->handlers[handlernum] != NULL) {
+        Py_INCREF(self->handlers[handlernum]);
+        return self->handlers[handlernum];
+    }
+
+#define APPEND(list, str)				\
+	{						\
+		PyObject *o = PyString_FromString(str);	\
+		if (o != NULL)				\
+			PyList_Append(list, o);		\
+		Py_XDECREF(o);				\
+	}
+
+    if (strcmp(name, "__members__") == 0) {
+        int i;
+        PyObject *rc = PyList_New(0);
+        for (i = 0; handler_info[i].name != NULL; i++) {
+            APPEND(rc, handler_info[i].name);
+        }
+        APPEND(rc, "ErrorCode");
+        APPEND(rc, "ErrorLineNumber");
+        APPEND(rc, "ErrorColumnNumber");
+        APPEND(rc, "ErrorByteIndex");
+        APPEND(rc, "ordered_attributes");
+        APPEND(rc, "returns_unicode");
+        APPEND(rc, "specified_attributes");
+
+#undef APPEND
+        return rc;
+    }
+    /* Unfortunately the Python/C API does not have all the right
+       consts, but judging from the code of Py_FindMethod,
+       const_casting the first parameter here is okay, at least
+       with the version of Python that we are building against.
+     */
+    return Py_FindMethod((PyMethodDef *)xmlparse_methods,
+			 (PyObject *)self, name);
+}
+
+static int
+sethandler(xmlparseobject *self, const char *name, PyObject* v)
+{
+    int handlernum = handlername2int(name);
+    if (handlernum != -1) {
+        Py_INCREF(v);
+        Py_XDECREF(self->handlers[handlernum]);
+        self->handlers[handlernum] = v;
+        handler_info[handlernum].setter(self->itself, 
+                                        handler_info[handlernum].handler);
+        return 1;
+    }
+    return 0;
+}
+
+static int
+xmlparse_setattr(xmlparseobject *self, char *name, PyObject *v)
+{
+    /* Set attribute 'name' to value 'v'. v==NULL means delete */
+    if (v == NULL) {
+        PyErr_SetString(PyExc_RuntimeError, "Cannot delete attribute");
+        return -1;
+    }
+    if (strcmp(name, "ordered_attributes") == 0) {
+        if (PyObject_IsTrue(v))
+            self->ordered_attributes = 1;
+        else
+            self->ordered_attributes = 0;
+        return 0;
+    }
+    if (strcmp(name, "returns_unicode") == 0) {
+        if (PyObject_IsTrue(v)) {
+#ifndef Py_USING_UNICODE
+            PyErr_SetString(PyExc_ValueError, 
+                            "Cannot return Unicode strings in Python 1.5");
+            return -1;
+#else
+            self->returns_unicode = 1;
+#endif
+        }
+        else
+            self->returns_unicode = 0;
+        return 0;
+    }
+    if (strcmp(name, "specified_attributes") == 0) {
+        if (PyObject_IsTrue(v))
+            self->specified_attributes = 1;
+        else
+            self->specified_attributes = 0;
+        return 0;
+    }
+    if (sethandler(self, name, v)) {
+        return 0;
+    }
+    PyErr_SetString(PyExc_AttributeError, name);
+    return -1;
+}
+
+#ifdef WITH_CYCLE_GC
+static int
+xmlparse_traverse(xmlparseobject *op, visitproc visit, void *arg)
+{
+    int i, err;
+    for (i = 0; handler_info[i].name != NULL; i++) {
+        if (!op->handlers[i])
+            continue;
+        err = visit(op->handlers[i], arg);
+        if (err)
+            return err;
+    }
+    return 0;
+}
+
+static int
+xmlparse_clear(xmlparseobject *op)
+{
+    clear_handlers(op, 0);
+    return 0;
+}
+#endif
+
+static const PyTypeObject Xmlparsetype_template = {
+    PyObject_HEAD_INIT(NULL)
+	0,				/*ob_size*/
+	"pyexpat.xmlparser",		/*tp_name*/
+	sizeof(xmlparseobject) + PyGC_HEAD_SIZE,/*tp_basicsize*/
+	0,				/*tp_itemsize*/
+	/* methods */
+	(destructor)xmlparse_dealloc,	/*tp_dealloc*/
+	(printfunc)0,		/*tp_print*/
+	(getattrfunc)xmlparse_getattr,	/*tp_getattr*/
+	(setattrfunc)xmlparse_setattr,	/*tp_setattr*/
+	(cmpfunc)0,		/*tp_compare*/
+	(reprfunc)0,		/*tp_repr*/
+	0,			/*tp_as_number*/
+	0,		/*tp_as_sequence*/
+	0,		/*tp_as_mapping*/
+	(hashfunc)0,		/*tp_hash*/
+	(ternaryfunc)0,		/*tp_call*/
+	(reprfunc)0,		/*tp_str*/
+	0,		/* tp_getattro */
+	0,		/* tp_setattro */
+	0,		/* tp_as_buffer */
+#ifdef Py_TPFLAGS_HAVE_GC
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /*tp_flags*/	
+#else
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_GC, /*tp_flags*/	
+#endif
+	0, /* Xmlparsetype__doc__, */ /* Documentation string */
+#ifdef WITH_CYCLE_GC
+	(traverseproc)xmlparse_traverse,	/* tp_traverse */
+	(inquiry)xmlparse_clear		/* tp_clear */
+#else
+	0, 0
+#endif
+};
+
+/* End of code for xmlparser objects */
+/* -------------------------------------------------------- */
+
+// the first parameter is always 0 for functions,
+// and only set for methods
+static PyObject *
+pyexpat_ParserCreate(PyObject* /*module*/, PyObject *args, PyObject *kw)
+{
+    char *encoding = NULL;
+    char *namespace_separator = NULL;
+    char *kwlist[] = {"encoding", "namespace_separator", NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kw, "|zz:ParserCreate", kwlist,
+                                     &encoding, &namespace_separator))
+        return NULL;
+    if (namespace_separator != NULL
+        && strlen(namespace_separator) > 1) {
+        PyErr_SetString(PyExc_ValueError,
+                        "namespace_separator must be at most one"
+                        " character, omitted, or None");
+        return NULL;
+    }
+    return newxmlparseobject(NULL /*module*/, encoding, namespace_separator);
+}
+
+static PyObject *
+pyexpat_ErrorString(PyObject * /*self*/, PyObject *args)
+{
+    long code = 0;
+
+    if (!PyArg_ParseTuple(args, "l:ErrorString", &code))
+        return NULL;
+    return Py_BuildValue("z", XML_ErrorString((enum XML_Error) code));
+}
+
+/* List of methods defined in the module */
+
+static const struct PyMethodDef pyexpat_methods[] = {
+    {"ParserCreate",	(PyCFunction)pyexpat_ParserCreate,
+     METH_VARARGS|METH_KEYWORDS, 0 /* pyexpat_ParserCreate__doc__ */},
+    {"ErrorString",	(PyCFunction)pyexpat_ErrorString,
+     METH_VARARGS, 0 /* pyexpat_ErrorString__doc__ */},
+ 
+    {NULL,	 (PyCFunction)NULL, 0, NULL}		/* sentinel */
+};
+
+/* Module docstring */
+
+#if PY_VERSION_HEX < 0x20000F0
+
+/* 1.5 compatibility: PyModule_AddObject */
+static int
+PyModule_AddObject(PyObject *m, char *name, PyObject *o)
+{
+    PyObject *dict;
+    if (!PyModule_Check(m) || o == NULL)
+        return -1;
+    dict = PyModule_GetDict(m);
+    if (dict == NULL)
+        return -1;
+    if (PyDict_SetItemString(dict, name, o))
+        return -1;
+    Py_DECREF(o);
+    return 0;
+}
+
+int 
+PyModule_AddIntConstant(PyObject *m, char *name, long value)
+{
+    return PyModule_AddObject(m, name, PyInt_FromLong(value));
+}
+
+static int 
+PyModule_AddStringConstant(PyObject *m, char *name, char *value)
+{
+    return PyModule_AddObject(m, name, PyString_FromString(value));
+}
+
+#endif
+
+
+/* Return a Python string that represents the version number without the
+ * extra cruft added by revision control, even if the right options were
+ * given to the "cvs export" command to make it not include the extra
+ * cruft.
+ */
+static PyObject *
+get_version_string(void)
+{
+    const char *rcsid = "$Revision: 2.57.6.6 $";
+    const char *rev = rcsid;
+    int i = 0;
+
+    while (!isdigit(*rev))
+        ++rev;
+    while (rev[i] != ' ' && rev[i] != '\0')
+        ++i;
+
+    return PyString_FromStringAndSize(rev, i);
+}
+
+/* Initialization function for the module */
+
+#ifndef MODULE_NAME
+#define MODULE_NAME "pyexpat"
+#else
+#error was defined
+#endif
+
+#ifndef MODULE_INITFUNC
+#define MODULE_INITFUNC initpyexpat
+#endif
+
+//void Log(const char* aText); // from logging.cpp
+
+DL_EXPORT(void) MODULE_INITFUNC(void)
+{
+    PyObject *m, *d;
+    PyObject *errmod_name = PyString_FromString(MODULE_NAME ".errors");
+    PyObject *errors_module;
+    PyObject *modelmod_name;
+    PyObject *model_module;
+    PyObject *sys_modules;
+    PyObject *ErrorObject;
+    PyTypeObject *xmlobj;
+
+    //Log("initpyexpat()");
+
+    /* Create the module and add the functions */
+    /* Unfortunately the Python/C API does not have all the right
+       consts, but judging from the code of Py_InitModule4,
+       const_casting the second parameter here is okay, at least
+       with the version of Python that we are building against.
+     */
+    m = Py_InitModule(MODULE_NAME, (PyMethodDef *) pyexpat_methods);
+    /* pyexpat_module_documentation */
+
+    xmlobj = PyObject_New(PyTypeObject, &PyType_Type);
+    *xmlobj = Xmlparsetype_template;
+    xmlobj->ob_type = &PyType_Type;
+    /*
+    if (PyType_Ready(xmlobj) < 0)
+	return;
+    */
+    SPyAddGlobalString("Xmlparsetype", (PyObject*)xmlobj);
+    PyModule_AddObject(m, "XMLParserType", (PyObject *) Xmlparsetype);
+
+    if (errmod_name == NULL)
+        return;
+    modelmod_name = PyString_FromString(MODULE_NAME ".model");
+    if (modelmod_name == NULL)
+        return;
+
+    /* Add some symbolic constants to the module */
+    ErrorObject = PyErr_NewException("xml.parsers.expat.ExpatError",
+				     NULL, NULL);
+    if (ErrorObject == NULL)
+      return;
+    Py_INCREF(ErrorObject);
+    //PyModule_AddObject(m, "error", ErrorObject);
+    SPyAddGlobalString("pyexpaterror", ErrorObject);
+    Py_INCREF(ErrorObject);
+    PyModule_AddObject(m, "ExpatError", ErrorObject);
+    /* Py_INCREF(&Xmlparsetype); I think this is unnecessary */
+	
+    PyModule_AddObject(m, "__version__", get_version_string());
+#if EXPAT_VERSION >= 0x015f02
+    PyModule_AddStringConstant(m, "EXPAT_VERSION",
+                               (char *) XML_ExpatVersion());
+    {
+        XML_Expat_Version info = XML_ExpatVersionInfo();
+        PyModule_AddObject(m, "version_info",
+                           Py_BuildValue("(iii)", info.major,
+                                         info.minor, info.micro));
+    }
+#endif
+    /* XXX When Expat supports some way of figuring out how it was
+       compiled, this should check and set native_encoding 
+       appropriately. 
+    */
+    PyModule_AddStringConstant(m, "native_encoding", "UTF-8");
+
+    sys_modules = PySys_GetObject("modules");
+    d = PyModule_GetDict(m);
+    errors_module = PyDict_GetItem(d, errmod_name);
+    if (errors_module == NULL) {
+        errors_module = PyModule_New(MODULE_NAME ".errors");
+        if (errors_module != NULL) {
+            PyDict_SetItem(sys_modules, errmod_name, errors_module);
+            /* gives away the reference to errors_module */
+            PyModule_AddObject(m, "errors", errors_module);
+        }
+    }
+    Py_DECREF(errmod_name);
+    model_module = PyDict_GetItem(d, modelmod_name);
+    if (model_module == NULL) {
+        model_module = PyModule_New(MODULE_NAME ".model");
+        if (model_module != NULL) {
+            PyDict_SetItem(sys_modules, modelmod_name, model_module);
+            /* gives away the reference to model_module */
+            PyModule_AddObject(m, "model", model_module);
+        }
+    }
+    Py_DECREF(modelmod_name);
+    if (errors_module == NULL || model_module == NULL)
+        /* Don't core dump later! */
+        return;
+
+#define MYCONST(name) \
+    PyModule_AddStringConstant(errors_module, #name, \
+                               (char*)XML_ErrorString(name))
+
+    MYCONST(XML_ERROR_NO_MEMORY);
+    MYCONST(XML_ERROR_SYNTAX);
+    MYCONST(XML_ERROR_NO_ELEMENTS);
+    MYCONST(XML_ERROR_INVALID_TOKEN);
+    MYCONST(XML_ERROR_UNCLOSED_TOKEN);
+    MYCONST(XML_ERROR_PARTIAL_CHAR);
+    MYCONST(XML_ERROR_TAG_MISMATCH);
+    MYCONST(XML_ERROR_DUPLICATE_ATTRIBUTE);
+    MYCONST(XML_ERROR_JUNK_AFTER_DOC_ELEMENT);
+    MYCONST(XML_ERROR_PARAM_ENTITY_REF);
+    MYCONST(XML_ERROR_UNDEFINED_ENTITY);
+    MYCONST(XML_ERROR_RECURSIVE_ENTITY_REF);
+    MYCONST(XML_ERROR_ASYNC_ENTITY);
+    MYCONST(XML_ERROR_BAD_CHAR_REF);
+    MYCONST(XML_ERROR_BINARY_ENTITY_REF);
+    MYCONST(XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF);
+    MYCONST(XML_ERROR_MISPLACED_XML_PI);
+    MYCONST(XML_ERROR_UNKNOWN_ENCODING);
+    MYCONST(XML_ERROR_INCORRECT_ENCODING);
+    MYCONST(XML_ERROR_UNCLOSED_CDATA_SECTION);
+    MYCONST(XML_ERROR_EXTERNAL_ENTITY_HANDLING);
+    MYCONST(XML_ERROR_NOT_STANDALONE);
+
+    PyModule_AddStringConstant(errors_module, "__doc__",
+                               "Constants used to describe error conditions.");
+
+#undef MYCONST
+
+#if EXPAT_VERSION >= 0x010200
+#define MYCONST(c) PyModule_AddIntConstant(m, #c, c)
+    MYCONST(XML_PARAM_ENTITY_PARSING_NEVER);
+    MYCONST(XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE);
+    MYCONST(XML_PARAM_ENTITY_PARSING_ALWAYS);
+#undef MYCONST
+#endif
+
+#if EXPAT_VERSION >= 0x015f00
+#define MYCONST(c) PyModule_AddIntConstant(model_module, #c, c)
+    PyModule_AddStringConstant(model_module, "__doc__",
+                     "Constants used to interpret content model information.");
+
+    MYCONST(XML_CTYPE_EMPTY);
+    MYCONST(XML_CTYPE_ANY);
+    MYCONST(XML_CTYPE_MIXED);
+    MYCONST(XML_CTYPE_NAME);
+    MYCONST(XML_CTYPE_CHOICE);
+    MYCONST(XML_CTYPE_SEQ);
+
+    MYCONST(XML_CQUANT_NONE);
+    MYCONST(XML_CQUANT_OPT);
+    MYCONST(XML_CQUANT_REP);
+    MYCONST(XML_CQUANT_PLUS);
+#undef MYCONST
+#endif
+}
+
+
+static void
+clear_handlers(xmlparseobject *self, int initial)
+{
+    int i = 0;
+    PyObject *temp;
+
+    for (; handler_info[i].name!=NULL; i++) {
+        if (initial)
+	    self->handlers[i]=NULL;
+	else {
+            temp = self->handlers[i];
+            self->handlers[i] = NULL;
+            Py_XDECREF(temp);
+	    handler_info[i].setter(self->itself, NULL);
+        }
+    }
+}
+
+typedef void (*pairsetter)(XML_Parser, void *handler1, void *handler2);
+
+static void
+pyxml_UpdatePairedHandlers(xmlparseobject *self, 
+                           int startHandler, 
+                           int endHandler,
+                           pairsetter setter)
+{
+    void *start_handler = NULL;
+    void *end_handler = NULL;
+
+    if (self->handlers[startHandler]
+        && self->handlers[startHandler] != Py_None) {
+        start_handler = handler_info[startHandler].handler;
+    }
+    if (self->handlers[endHandler]
+        && self->handlers[endHandler] != Py_None) {
+        end_handler = handler_info[endHandler].handler;
+    }
+    setter(self->itself, start_handler, end_handler);
+}
+
+static void
+pyxml_SetStartElementHandler(XML_Parser parser, void * /*junk*/)
+{
+    pyxml_UpdatePairedHandlers((xmlparseobject *)XML_GetUserData(parser),
+                               StartElement, EndElement,
+                               (pairsetter)XML_SetElementHandler);
+}
+
+static void
+pyxml_SetEndElementHandler(XML_Parser parser, void * /*junk*/)
+{
+    pyxml_UpdatePairedHandlers((xmlparseobject *)XML_GetUserData(parser), 
+                               StartElement, EndElement,
+                               (pairsetter)XML_SetElementHandler);
+}
+
+static void
+pyxml_SetStartNamespaceDeclHandler(XML_Parser parser, void * /*junk*/)
+{
+    pyxml_UpdatePairedHandlers((xmlparseobject *)XML_GetUserData(parser), 
+                               StartNamespaceDecl, EndNamespaceDecl,
+                               (pairsetter)XML_SetNamespaceDeclHandler);
+}
+
+static void
+pyxml_SetEndNamespaceDeclHandler(XML_Parser parser, void * /*junk*/)
+{
+    pyxml_UpdatePairedHandlers((xmlparseobject *)XML_GetUserData(parser), 
+                               StartNamespaceDecl, EndNamespaceDecl,
+                               (pairsetter)XML_SetNamespaceDeclHandler);
+}
+
+static void
+pyxml_SetStartCdataSection(XML_Parser parser, void * /*junk*/)
+{
+    pyxml_UpdatePairedHandlers((xmlparseobject *)XML_GetUserData(parser),
+                               StartCdataSection, EndCdataSection,
+                               (pairsetter)XML_SetCdataSectionHandler);
+}
+
+static void
+pyxml_SetEndCdataSection(XML_Parser parser, void * /*junk*/)
+{
+    pyxml_UpdatePairedHandlers((xmlparseobject *)XML_GetUserData(parser), 
+                               StartCdataSection, EndCdataSection, 
+                               (pairsetter)XML_SetCdataSectionHandler);
+}
+
+#if EXPAT_VERSION >= 0x010200
+
+static void
+pyxml_SetStartDoctypeDeclHandler(XML_Parser parser, void * /*junk*/)
+{
+    pyxml_UpdatePairedHandlers((xmlparseobject *)XML_GetUserData(parser),
+                               StartDoctypeDecl, EndDoctypeDecl,
+                               (pairsetter)XML_SetDoctypeDeclHandler);
+}
+
+static void
+pyxml_SetEndDoctypeDeclHandler(XML_Parser parser, void * /*junk*/)
+{
+    pyxml_UpdatePairedHandlers((xmlparseobject *)XML_GetUserData(parser),
+                               StartDoctypeDecl, EndDoctypeDecl,
+                               (pairsetter)XML_SetDoctypeDeclHandler);
+}
+
+#endif
+
+const struct HandlerInfo handler_info[64] = {
+    {"StartElementHandler", 
+     pyxml_SetStartElementHandler, 
+     (xmlhandler)my_StartElementHandler},
+    {"EndElementHandler", 
+     pyxml_SetEndElementHandler, 
+     (xmlhandler)my_EndElementHandler},
+    {"ProcessingInstructionHandler", 
+     (xmlhandlersetter)XML_SetProcessingInstructionHandler,
+     (xmlhandler)my_ProcessingInstructionHandler},
+    {"CharacterDataHandler", 
+     (xmlhandlersetter)XML_SetCharacterDataHandler,
+     (xmlhandler)my_CharacterDataHandler},
+    {"UnparsedEntityDeclHandler", 
+     (xmlhandlersetter)XML_SetUnparsedEntityDeclHandler,
+     (xmlhandler)my_UnparsedEntityDeclHandler },
+    {"NotationDeclHandler", 
+     (xmlhandlersetter)XML_SetNotationDeclHandler,
+     (xmlhandler)my_NotationDeclHandler },
+    {"StartNamespaceDeclHandler", 
+     pyxml_SetStartNamespaceDeclHandler,
+     (xmlhandler)my_StartNamespaceDeclHandler },
+    {"EndNamespaceDeclHandler", 
+     pyxml_SetEndNamespaceDeclHandler,
+     (xmlhandler)my_EndNamespaceDeclHandler },
+    {"CommentHandler",
+     (xmlhandlersetter)XML_SetCommentHandler,
+     (xmlhandler)my_CommentHandler},
+    {"StartCdataSectionHandler",
+     pyxml_SetStartCdataSection,
+     (xmlhandler)my_StartCdataSectionHandler},
+    {"EndCdataSectionHandler",
+     pyxml_SetEndCdataSection,
+     (xmlhandler)my_EndCdataSectionHandler},
+    {"DefaultHandler",
+     (xmlhandlersetter)XML_SetDefaultHandler,
+     (xmlhandler)my_DefaultHandler},
+    {"DefaultHandlerExpand",
+     (xmlhandlersetter)XML_SetDefaultHandlerExpand,
+     (xmlhandler)my_DefaultHandlerExpandHandler},
+    {"NotStandaloneHandler",
+     (xmlhandlersetter)XML_SetNotStandaloneHandler,
+     (xmlhandler)my_NotStandaloneHandler},
+    {"ExternalEntityRefHandler",
+     (xmlhandlersetter)XML_SetExternalEntityRefHandler,
+     (xmlhandler)my_ExternalEntityRefHandler },
+#if EXPAT_VERSION >= 0x010200
+    {"StartDoctypeDeclHandler",
+     pyxml_SetStartDoctypeDeclHandler,
+     (xmlhandler)my_StartDoctypeDeclHandler},
+    {"EndDoctypeDeclHandler",
+     pyxml_SetEndDoctypeDeclHandler,
+     (xmlhandler)my_EndDoctypeDeclHandler},
+#endif
+#if EXPAT_VERSION == 0x010200
+    {"ExternalParsedEntityDeclHandler",
+     (xmlhandlersetter)XML_SetExternalParsedEntityDeclHandler,
+     (xmlhandler)my_ExternalParsedEntityDeclHandler},
+    {"InternalParsedEntityDeclHandler",
+     (xmlhandlersetter)XML_SetInternalParsedEntityDeclHandler,
+     (xmlhandler)my_InternalParsedEntityDeclHandler},
+#endif
+#if EXPAT_VERSION >= 0x015f00
+    {"EntityDeclHandler",
+     (xmlhandlersetter)XML_SetEntityDeclHandler,
+     (xmlhandler)my_EntityDeclHandler},
+    {"XmlDeclHandler",
+     (xmlhandlersetter)XML_SetXmlDeclHandler,
+     (xmlhandler)my_XmlDeclHandler},
+    {"ElementDeclHandler",
+     (xmlhandlersetter)XML_SetElementDeclHandler,
+     (xmlhandler)my_ElementDeclHandler},
+    {"AttlistDeclHandler",
+     (xmlhandlersetter)XML_SetAttlistDeclHandler,
+     (xmlhandler)my_AttlistDeclHandler},
+#endif /* Expat version 1.95 or better */
+
+    {NULL, NULL, NULL} /* sentinel */
+};
+
+}
